<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MainActivity.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.location.Location&#10;import android.location.LocationListener&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.OnMapReadyCallback&#10;import com.google.android.gms.maps.SupportMapFragment&#10;&#10;class MainActivity : AppCompatActivity(), SensorEventListener, LocationListener, OnMapReadyCallback {&#10;&#10;    private lateinit var sensorManager: SensorManager&#10;    private lateinit var locationHelper: LocationHelper&#10;    private lateinit var overlayText: TextView&#10;    private lateinit var selectButton: Button&#10;    private lateinit var azimuthArrow: View&#10;    private lateinit var elevationArrow: View&#10;&#10;    private var googleMap: GoogleMap? = null&#10;&#10;    private var currentAzimuth = 0.0&#10;    private var currentPitch = 0.0&#10;    private var targetAzimuth = 0.0&#10;    private var targetElevation = 0.0&#10;&#10;    private var satLat = 45.0&#10;    private var satLon = 8.0&#10;    private var satAltMeters = 500000.0&#10;&#10;    private var lastGoodLocation: Location? = null&#10;&#10;    private var tle1: String? = null&#10;    private var tle2: String? = null&#10;    private var satName: String? = null&#10;&#10;    //private var maxLosElevation: Double = Double.NEGATIVE_INFINITY&#10;    //private var lastAos: Boolean = false&#10;&#10;    private var periodMin: Double = 92.0&#10;    private var inclination: Double = 51.6&#10;    private var heightKm: Double = 420.0&#10;&#10;    private var aosTime: Long = -1&#10;    private var losTime: Long = -1&#10;&#10;    // Remove deprecated startActivityForResult usage and use Activity Result API&#10;    private val selectSatelliteLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt;&#10;        Log.d(&quot;SatFinder2&quot;, &quot;selectSatelliteLauncher called: result=$result&quot;)&#10;        val data = result.data&#10;        if (result.resultCode == Activity.RESULT_OK &amp;&amp; data != null) {&#10;            ActivityResultHelper.handleSatelliteSelectionResult(&#10;                this,&#10;                data&#10;            ) { tle1New, tle2New, satNameNew, satLatNew, satLonNew, satAltMetersNew, periodMinNew, inclinationNew, heightKmNew, aosTimeNew, losTimeNew -&gt;&#10;                Log.d(&quot;SatFinder2&quot;, &quot;selectSatelliteLauncher: tle1New=$tle1New, tle2New=$tle2New, satNameNew=$satNameNew&quot;)&#10;                tle1 = tle1New&#10;                tle2 = tle2New&#10;                satName = satNameNew&#10;                satLat = satLatNew&#10;                satLon = satLonNew&#10;                satAltMeters = satAltMetersNew&#10;                periodMin = periodMinNew&#10;                inclination = inclinationNew&#10;                heightKm = heightKmNew&#10;                aosTime = aosTimeNew&#10;                losTime = losTimeNew&#10;                updateOverlay()&#10;                updateSatelliteDirection()&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SourceLockedOrientationActivity&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Set screen orientation to portrait&#10;        requestedOrientation = android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;        Log.d(&quot;Sgp4Debug&quot;, &quot;Test: MainActivity started&quot;)&#10;&#10;        overlayText = findViewById(R.id.overlayText)&#10;        selectButton = findViewById(R.id.selectSatelliteButton)&#10;        azimuthArrow = findViewById(R.id.azimuthArrow)&#10;        elevationArrow = findViewById(R.id.elevationArrow)&#10;&#10;        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager&#10;        locationHelper = LocationHelper(this, this)&#10;&#10;        if (!PermissionHelper.isPermissionGranted(this, Manifest.permission.ACCESS_FINE_LOCATION)) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 1)&#10;        } else {&#10;            locationHelper.startLocationUpdates()&#10;        }&#10;&#10;        selectButton.setOnClickListener {&#10;            val intent = Intent(this, SatelliteSelectionActivity::class.java)&#10;            // Example of usage:&#10;            selectSatelliteLauncher.launch(intent)&#10;        }&#10;&#10;        // Set pivot points after layout to allow rotation around center&#10;        azimuthArrow.viewTreeObserver.addOnGlobalLayoutListener {&#10;            azimuthArrow.pivotX = azimuthArrow.width / 2f&#10;            azimuthArrow.pivotY = azimuthArrow.height / 2f&#10;        }&#10;        elevationArrow.viewTreeObserver.addOnGlobalLayoutListener {&#10;            elevationArrow.pivotX = elevationArrow.width / 2f&#10;            elevationArrow.pivotY = elevationArrow.height / 2f&#10;        }&#10;&#10;        // Initialize map&#10;        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment&#10;        mapFragment.getMapAsync(this)&#10;&#10;        // Load last fix from preferences&#10;        lastGoodLocation = PreferencesHelper.loadLocation(this)&#10;        // Get TLE data from intent&#10;        tle1 = intent.getStringExtra(&quot;tle1&quot;)&#10;        tle2 = intent.getStringExtra(&quot;tle2&quot;)&#10;        satName = intent.getStringExtra(&quot;satName&quot;)&#10;        periodMin = intent.getDoubleExtra(&quot;periodMin&quot;, periodMin)&#10;        inclination = intent.getDoubleExtra(&quot;inclination&quot;, inclination)&#10;        heightKm = intent.getDoubleExtra(&quot;heightKm&quot;, heightKm)&#10;        val aosMillis = intent.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losMillis = intent.getLongExtra(&quot;los&quot;, -1L)&#10;        if (aosMillis &gt; 0 &amp;&amp; losMillis &gt; 0) {&#10;            aosTime = aosMillis&#10;            losTime = losMillis&#10;        }&#10;        // Lade TLE-Daten aus Preferences nur, wenn sie im Intent oder Speicher nicht gültig sind&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2) || satName == null) {&#10;            val (savedTle1, savedTle2, savedSatName) = PreferencesHelper.loadSatelliteData(this)&#10;            tle1 = savedTle1&#10;            tle2 = savedTle2&#10;            satName = savedSatName&#10;        }&#10;        // Wenn immer noch keine gültigen TLE-Daten vorhanden sind, Preferences löschen und Auswahl erzwingen&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            // Preferences löschen&#10;            val prefs = getSharedPreferences(&quot;satfinder_prefs&quot;, MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            overlayText.text = &quot;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&quot;&#10;            // Auswahl-Dialog starten&#10;            val intent = Intent(this, SatelliteSelectionActivity::class.java)&#10;            selectSatelliteLauncher.launch(intent)&#10;        } else {&#10;            updateOverlay()&#10;        }&#10;    }&#10;&#10;    // Overlay-logic outsourced&#10;    @SuppressLint(&quot;SetTextI18n&quot;)&#10;    private fun updateOverlay() {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            overlayText.text = &quot;No TLE-data. Select satellite.&quot;&#10;            return&#10;        }&#10;        OverlayViewHelper.updateOverlay(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            satName = satName,&#10;            lastGoodLocation = lastGoodLocation,&#10;            aosTime = aosTime,&#10;            losTime = losTime&#10;        )&#10;    }&#10;&#10;    // FixStatus-Logik ausgelagert&#10;    private fun updateFixStatus() {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) return&#10;        OverlayViewHelper.updateFixStatus(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            lastGoodLocation = lastGoodLocation,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            getFixColor = OverlayViewHelper::getFixColor,&#10;            getGpsStatus = OverlayViewHelper::getGpsStatus&#10;        )&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        LifecycleHelper.registerSensorListener(sensorManager, this, android.hardware.Sensor.TYPE_ROTATION_VECTOR)&#10;        updateFixStatus()&#10;        updateOverlay()&#10;        lastGoodLocation?.let { loc -&gt;&#10;            MapHelper.updateMapPosition(googleMap, loc)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        LifecycleHelper.unregisterSensorListener(sensorManager, this)&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        locationHelper.startLocationUpdates()&#10;    }&#10;&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type == Sensor.TYPE_ROTATION_VECTOR) {&#10;            val (azimuth, pitch) = SensorHelper.getAzimuthAndPitch(event)&#10;            currentAzimuth = azimuth&#10;            currentPitch = pitch&#10;            updateSatelliteDirection()&#10;        }&#10;    }&#10;&#10;    override fun onMapReady(map: GoogleMap) {&#10;        googleMap = map&#10;        googleMap?.uiSettings?.isMyLocationButtonEnabled = true&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {&#10;            googleMap?.isMyLocationEnabled = true&#10;        }&#10;        // Map-Logik ausgelagert&#10;        lastGoodLocation?.let {&#10;            MapHelper.updateMapPosition(googleMap, it)&#10;        }&#10;    }&#10;&#10;    override fun onLocationChanged(location: Location) {&#10;        val hasFix = location.hasAccuracy() &amp;&amp; location.accuracy &lt; 1000&#10;        if (hasFix) {&#10;            location.time = System.currentTimeMillis()&#10;            lastGoodLocation = location&#10;            PreferencesHelper.saveLocation(this, location)&#10;        }&#10;        OverlayViewHelper.updateOverlay(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            satName = satName,&#10;            lastGoodLocation = lastGoodLocation,&#10;            aosTime = aosTime,&#10;            losTime = losTime&#10;        )&#10;        updateSatelliteDirection()&#10;        MapHelper.updateMapPosition(googleMap, location)&#10;    }&#10;&#10;    // Example method to calculate and display the direction to the satellite&#10;    private fun updateSatelliteDirection() {&#10;        val tle1 = this.tle1&#10;        val tle2 = this.tle2&#10;        val location = lastGoodLocation&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2) || location == null) {&#10;            return&#10;        }&#10;        val now = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;        val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;        //Log.d(&quot;Sgp4Debug&quot;, &quot;[updateSatelliteDirection] TLE1=$tle1 TLE2=$tle2 NOW=$now EPOCH=$epoch&quot;)&#10;        if (epoch == null) {&#10;            android.util.Log.e(&quot;Sgp4Debug&quot;, &quot;updateSatelliteDirection: Epoch not actualized&quot;)&#10;            return&#10;        }&#10;        val satPos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, now, epoch)&#10;        if (satPos != null) {&#10;            // UI-Update ausgelagert&#10;            OverlayViewHelper.updateSatelliteDirectionOverlay(&#10;                overlayText = overlayText,&#10;                location = location,&#10;                satPos = satPos,&#10;                satName = satName,&#10;                currentAzimuth = currentAzimuth,&#10;                currentPitch = currentPitch,&#10;                tle1 = tle1!!,&#10;                tle2 = tle2!!&#10;            )&#10;            val azimuth = SatelliteMathHelper.calculateAzimuth(location.latitude, location.longitude, satPos.lat, satPos.lon)&#10;            val elevation = SatelliteMathHelper.calculateElevation(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            val azimuthGeo = (450 - azimuth) % 360&#10;            val azimuthFixed = if (azimuthGeo &lt; 0) azimuthGeo + 360 else azimuthGeo&#10;            val azError = ((azimuthFixed - currentAzimuth + 540) % 360) - 180&#10;            val elError = elevation - getDeviceLookElevation()&#10;            android.util.Log.d(&quot;Sgp4Debug&quot;, &quot;azError=$azError, elError=$elError, currentAzimuth=$currentAzimuth, currentPitch=$currentPitch&quot;)&#10;            updateAzimuthBar(azError)&#10;            updateElevationBar(elError)&#10;        }&#10;    }&#10;&#10;    // Helper function: Calculate the elevation of the device's line of sight relative to the horizon&#10;    private fun getDeviceLookElevation(): Double {&#10;        return SensorHelper.getDeviceLookElevation(currentAzimuth, currentPitch)&#10;    }&#10;&#10;    private fun updateAzimuthBar(error: Double) {&#10;        ArrowViewHelper.updateAzimuthBar(azimuthArrow, error)&#10;    }&#10;&#10;    private fun updateElevationBar(error: Double) {&#10;        ArrowViewHelper.updateElevationBar(elevationArrow, error)&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}&#10;&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        PermissionHelper.handlePermissionResult(&#10;            requestCode,&#10;            permissions,&#10;            grantResults,&#10;            1,&#10;            onGranted = {&#10;                Toast.makeText(this, &quot;Permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;                locationHelper.startLocationUpdates()&#10;            },&#10;            onDenied = {&#10;                Toast.makeText(this, &quot;GPS permission is required&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        )&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        locationHelper.stopLocationUpdates()&#10;        LifecycleHelper.unlockScreenOrientation(this)&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.location.Location&#10;import android.location.LocationListener&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.OnMapReadyCallback&#10;import com.google.android.gms.maps.SupportMapFragment&#10;&#10;class MainActivity : AppCompatActivity(), SensorEventListener, LocationListener, OnMapReadyCallback {&#10;&#10;    private lateinit var sensorManager: SensorManager&#10;    private lateinit var locationHelper: LocationHelper&#10;    private lateinit var overlayText: TextView&#10;    private lateinit var selectButton: Button&#10;&#10;    private var googleMap: GoogleMap? = null&#10;&#10;    private var currentAzimuth = 0.0&#10;    private var currentPitch = 0.0&#10;    private var targetAzimuth = 0.0&#10;    private var targetElevation = 0.0&#10;&#10;    private var satLat = 45.0&#10;    private var satLon = 8.0&#10;    private var satAltMeters = 500000.0&#10;&#10;    private var lastGoodLocation: Location? = null&#10;&#10;    private var tle1: String? = null&#10;    private var tle2: String? = null&#10;    private var satName: String? = null&#10;&#10;    //private var maxLosElevation: Double = Double.NEGATIVE_INFINITY&#10;    //private var lastAos: Boolean = false&#10;&#10;    private var periodMin: Double = 92.0&#10;    private var inclination: Double = 51.6&#10;    private var heightKm: Double = 420.0&#10;&#10;    private var aosTime: Long = -1&#10;    private var losTime: Long = -1&#10;&#10;    // Remove deprecated startActivityForResult usage and use Activity Result API&#10;    private val selectSatelliteLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt;&#10;        Log.d(&quot;SatFinder2&quot;, &quot;selectSatelliteLauncher called: result=$result&quot;)&#10;        val data = result.data&#10;        if (result.resultCode == Activity.RESULT_OK &amp;&amp; data != null) {&#10;            ActivityResultHelper.handleSatelliteSelectionResult(&#10;                this,&#10;                data&#10;            ) { tle1New, tle2New, satNameNew, satLatNew, satLonNew, satAltMetersNew, periodMinNew, inclinationNew, heightKmNew, aosTimeNew, losTimeNew -&gt;&#10;                Log.d(&quot;SatFinder2&quot;, &quot;selectSatelliteLauncher: tle1New=$tle1New, tle2New=$tle2New, satNameNew=$satNameNew&quot;)&#10;                tle1 = tle1New&#10;                tle2 = tle2New&#10;                satName = satNameNew&#10;                satLat = satLatNew&#10;                satLon = satLonNew&#10;                satAltMeters = satAltMetersNew&#10;                periodMin = periodMinNew&#10;                inclination = inclinationNew&#10;                heightKm = heightKmNew&#10;                aosTime = aosTimeNew&#10;                losTime = losTimeNew&#10;                updateOverlay()&#10;                updateSatelliteDirection()&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;SourceLockedOrientationActivity&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        // Set screen orientation to portrait&#10;        requestedOrientation = android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;        Log.d(&quot;Sgp4Debug&quot;, &quot;Test: MainActivity started&quot;)&#10;&#10;        overlayText = findViewById(R.id.overlayText)&#10;        selectButton = findViewById(R.id.selectSatelliteButton)&#10;&#10;        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager&#10;        locationHelper = LocationHelper(this, this)&#10;&#10;        if (!PermissionHelper.isPermissionGranted(this, Manifest.permission.ACCESS_FINE_LOCATION)) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION), 1)&#10;        } else {&#10;            locationHelper.startLocationUpdates()&#10;        }&#10;&#10;        selectButton.setOnClickListener {&#10;            val intent = Intent(this, SatelliteSelectionActivity::class.java)&#10;            // Example of usage:&#10;            selectSatelliteLauncher.launch(intent)&#10;        }&#10;&#10;        // Initialize map&#10;        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment&#10;        mapFragment.getMapAsync(this)&#10;&#10;        // Load last fix from preferences&#10;        lastGoodLocation = PreferencesHelper.loadLocation(this)&#10;        // Get TLE data from intent&#10;        tle1 = intent.getStringExtra(&quot;tle1&quot;)&#10;        tle2 = intent.getStringExtra(&quot;tle2&quot;)&#10;        satName = intent.getStringExtra(&quot;satName&quot;)&#10;        periodMin = intent.getDoubleExtra(&quot;periodMin&quot;, periodMin)&#10;        inclination = intent.getDoubleExtra(&quot;inclination&quot;, inclination)&#10;        heightKm = intent.getDoubleExtra(&quot;heightKm&quot;, heightKm)&#10;        val aosMillis = intent.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losMillis = intent.getLongExtra(&quot;los&quot;, -1L)&#10;        if (aosMillis &gt; 0 &amp;&amp; losMillis &gt; 0) {&#10;            aosTime = aosMillis&#10;            losTime = losMillis&#10;        }&#10;        // Lade TLE-Daten aus Preferences nur, wenn sie im Intent oder Speicher nicht gültig sind&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2) || satName == null) {&#10;            val (savedTle1, savedTle2, savedSatName) = PreferencesHelper.loadSatelliteData(this)&#10;            tle1 = savedTle1&#10;            tle2 = savedTle2&#10;            satName = savedSatName&#10;        }&#10;        // Wenn immer noch keine gültigen TLE-Daten vorhanden sind, Preferences löschen und Auswahl erzwingen&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            // Preferences löschen&#10;            val prefs = getSharedPreferences(&quot;satfinder_prefs&quot;, MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            overlayText.text = &quot;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&quot;&#10;            // Auswahl-Dialog starten&#10;            val intent = Intent(this, SatelliteSelectionActivity::class.java)&#10;            selectSatelliteLauncher.launch(intent)&#10;        } else {&#10;            updateOverlay()&#10;        }&#10;    }&#10;&#10;    // Overlay-logic outsourced&#10;    @SuppressLint(&quot;SetTextI18n&quot;)&#10;    private fun updateOverlay() {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            overlayText.text = &quot;No TLE-data. Select satellite.&quot;&#10;            return&#10;        }&#10;        OverlayViewHelper.updateOverlay(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            satName = satName,&#10;            lastGoodLocation = lastGoodLocation,&#10;            aosTime = aosTime,&#10;            losTime = losTime&#10;        )&#10;    }&#10;&#10;    // FixStatus-Logik ausgelagert&#10;    private fun updateFixStatus() {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) return&#10;        OverlayViewHelper.updateFixStatus(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            lastGoodLocation = lastGoodLocation,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            getFixColor = OverlayViewHelper::getFixColor,&#10;            getGpsStatus = OverlayViewHelper::getGpsStatus&#10;        )&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        LifecycleHelper.registerSensorListener(sensorManager, this, android.hardware.Sensor.TYPE_ROTATION_VECTOR)&#10;        updateFixStatus()&#10;        updateOverlay()&#10;        lastGoodLocation?.let { loc -&gt;&#10;            MapHelper.updateMapPosition(googleMap, loc)&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        LifecycleHelper.unregisterSensorListener(sensorManager, this)&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        locationHelper.startLocationUpdates()&#10;    }&#10;&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type == Sensor.TYPE_ROTATION_VECTOR) {&#10;            val (azimuth, pitch) = SensorHelper.getAzimuthAndPitch(event)&#10;            currentAzimuth = azimuth&#10;            currentPitch = pitch&#10;            updateSatelliteDirection()&#10;        }&#10;    }&#10;&#10;    override fun onMapReady(map: GoogleMap) {&#10;        googleMap = map&#10;        googleMap?.uiSettings?.isMyLocationButtonEnabled = true&#10;        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {&#10;            googleMap?.isMyLocationEnabled = true&#10;        }&#10;        // Map-Logik ausgelagert&#10;        lastGoodLocation?.let {&#10;            MapHelper.updateMapPosition(googleMap, it)&#10;        }&#10;    }&#10;&#10;    override fun onLocationChanged(location: Location) {&#10;        val hasFix = location.hasAccuracy() &amp;&amp; location.accuracy &lt; 1000&#10;        if (hasFix) {&#10;            location.time = System.currentTimeMillis()&#10;            lastGoodLocation = location&#10;            PreferencesHelper.saveLocation(this, location)&#10;        }&#10;        OverlayViewHelper.updateOverlay(&#10;            context = this,&#10;            overlayText = overlayText,&#10;            tle1 = tle1,&#10;            tle2 = tle2,&#10;            satName = satName,&#10;            lastGoodLocation = lastGoodLocation,&#10;            aosTime = aosTime,&#10;            losTime = losTime&#10;        )&#10;        updateSatelliteDirection()&#10;        MapHelper.updateMapPosition(googleMap, location)&#10;    }&#10;&#10;    // Example method to calculate and display the direction to the satellite&#10;    private fun updateSatelliteDirection() {&#10;        val tle1 = this.tle1&#10;        val tle2 = this.tle2&#10;        val location = lastGoodLocation&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2) || location == null) {&#10;            return&#10;        }&#10;        val now = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;        val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;        //Log.d(&quot;Sgp4Debug&quot;, &quot;[updateSatelliteDirection] TLE1=$tle1 TLE2=$tle2 NOW=$now EPOCH=$epoch&quot;)&#10;        if (epoch == null) {&#10;            android.util.Log.e(&quot;Sgp4Debug&quot;, &quot;updateSatelliteDirection: Epoch not actualized&quot;)&#10;            return&#10;        }&#10;        val satPos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, now, epoch)&#10;        if (satPos != null) {&#10;            // UI-Update ausgelagert&#10;            OverlayViewHelper.updateSatelliteDirectionOverlay(&#10;                overlayText = overlayText,&#10;                location = location,&#10;                satPos = satPos,&#10;                satName = satName,&#10;                currentAzimuth = currentAzimuth,&#10;                currentPitch = currentPitch,&#10;                tle1 = tle1!!,&#10;                tle2 = tle2!!&#10;            )&#10;        }&#10;    }&#10;&#10;    // Helper function: Calculate the elevation of the device's line of sight relative to the horizon&#10;    private fun getDeviceLookElevation(): Double {&#10;        return SensorHelper.getDeviceLookElevation(currentAzimuth, currentPitch)&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}&#10;&#10;    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)&#10;        PermissionHelper.handlePermissionResult(&#10;            requestCode,&#10;            permissions,&#10;            grantResults,&#10;            1,&#10;            onGranted = {&#10;                Toast.makeText(this, &quot;Permission granted&quot;, Toast.LENGTH_SHORT).show()&#10;                locationHelper.startLocationUpdates()&#10;            },&#10;            onDenied = {&#10;                Toast.makeText(this, &quot;GPS permission is required&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        )&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        locationHelper.stopLocationUpdates()&#10;        LifecycleHelper.unlockScreenOrientation(this)&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;&#10;object MapHelper {&#10;    /**&#10;     * Centers the map on the given location and adds a marker.&#10;     * @param googleMap The GoogleMap instance (nullable)&#10;     * @param location The location to center and mark&#10;     */&#10;    fun updateMapPosition(googleMap: GoogleMap?, location: Location) {&#10;        if (googleMap == null) return&#10;        val pos = LatLng(location.latitude, location.longitude)&#10;        googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(pos, 16f))&#10;        googleMap.clear()&#10;        googleMap.addMarker(MarkerOptions().position(pos).title(&quot;Present Position&quot;))&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/OverlayViewHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/OverlayViewHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.location.LocationManager&#10;import android.text.Html&#10;import android.util.Log&#10;import android.widget.TextView&#10;import java.util.*&#10;import kotlin.math.abs&#10;&#10;object OverlayViewHelper {&#10;    fun updateOverlay(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        satName: String?,&#10;        lastGoodLocation: Location?,&#10;        aosTime: Long,&#10;        losTime: Long&#10;    ) {&#10;        val satDisplay = satName ?: &quot;(no satellite selected)&quot;&#10;        val loc = lastGoodLocation ?: run {&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                val locTmp = Location(LocationManager.GPS_PROVIDER)&#10;                locTmp.latitude = lat&#10;                locTmp.longitude = lon&#10;                locTmp.altitude = alt&#10;                locTmp.time = time&#10;                locTmp&#10;            } else null&#10;        }&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        // ab hier sind tle1 und tle2 garantiert nicht null und gültig&#10;        val tle1Str = tle1!!&#10;        val tle2Str = tle2!!&#10;        var aosLos = &quot;--&quot;&#10;        var satPos: Sgp4Util.SatPos? = null&#10;        var epoch: Date? = null&#10;        var distance: Double?&#10;        var speedStr = &quot;--&quot;&#10;        val satPosInfo = &quot;Sat-Pos: --&quot;&#10;        try {&#10;            epoch = TleHelper.extractEpochFromTle(tle1Str)&#10;            val utcNow = Date() // aktuelle Zeit verwenden&#10;            if (loc != null &amp;&amp; epoch != null) {&#10;                satPos = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, utcNow, epoch)&#10;                // Debug: Prüfe, ob satPos sich bei Satellitenwechsel ändert&#10;                Log.d(&quot;SatFinder1&quot;, &quot;Name: $satName satPos: $satPos, tle1: $tle1Str, tle2: $tle2Str, utcNow: $utcNow, epoch: $epoch&quot;)&#10;                val elev = satPos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                val az = satPos?.let { SatelliteMathHelper.calculateAzimuth(loc.latitude, loc.longitude, it.lat, it.lon) }&#10;                // Debug: Prüfe, ob elev/az sich bei Satellitenwechsel ändern&#10;                Log.d(&quot;SatFinder1&quot;, &quot;elev: $elev, az: $az&quot;)&#10;                distance = satPos?.let { SatelliteMathHelper.calculateDistance(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                aosLos = if (elev != null &amp;&amp; elev &gt; 0.0) &quot;AOS&quot; else &quot;LOS&quot;&#10;                // Always calculate speed&#10;                val nowDate = utcNow&#10;                val dtSec = 10.0&#10;                val futureDate = Date(nowDate.time + (dtSec * 1000).toLong())&#10;                val satPosFuture = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, futureDate, epoch)&#10;                if (satPos != null &amp;&amp; satPosFuture != null) {&#10;                    val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(loc, satPos, satPosFuture, dtSec)&#10;                    speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, radialSpeed)&#10;                }&#10;                // Round values and adjust units&#10;                val azStr = az?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val elStr = elev?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val distStr = distance?.let { String.format(Locale.US, &quot;%.1f km&quot;, it/1000.0) } ?: &quot;--&quot;&#10;                val speedStrRounded = speedStr&#10;                // Calculate next AOS time if LOS&#10;                var nextAosStr = &quot;--&quot;&#10;                if (aosLos == &quot;LOS&quot; &amp;&amp; tle1 != null &amp;&amp; tle2 != null &amp;&amp; loc != null &amp;&amp; epoch != null) {&#10;                    try {&#10;                        val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;                        var testTime: Date&#10;                        val maxSearch = 24 * 3600 // max 24h search&#10;                        for (i in 1..maxSearch step 10) { // 10s steps&#10;                            testTime = Date(utcNow.time + i * 1000L)&#10;                            val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, testTime, epoch)&#10;                            val elevTest = pos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) } ?: 0.0&#10;                            if (elevTest &gt; 0) {&#10;                                nextAosStr = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.US).format(testTime)&#10;                                break&#10;                            }&#10;                        }&#10;                    } catch (_: Exception) {}&#10;                }&#10;                // AOS: Show time only when LOS&#10;                val fixStatus = if (loc != null &amp;&amp; loc.hasAccuracy() &amp;&amp; loc.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - loc.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;                val aosLosStr = if (aosLos == &quot;LOS&quot; &amp;&amp; nextAosStr != &quot;--&quot;) &quot;LOS (next rise: $nextAosStr)&quot; else aosLos&#10;                val text = &quot;&quot;&quot;&#10;                    Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                    Distance: $distStr, Speed: $speedStrRounded&lt;br&gt;&#10;                    Fix: $fixStatus&lt;br&gt;&#10;                    Status: $aosLosStr&lt;br&gt;&#10;                    $satPosInfo&lt;br&gt;&#10;                    Satellite: $satDisplay&#10;                &quot;&quot;&quot;.trimIndent()&#10;                overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;            }&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    fun updateFixStatus(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        lastGoodLocation: Location?,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        getFixColor: (String) -&gt; Int,&#10;        getGpsStatus: () -&gt; String&#10;    ) {&#10;        // FixStatus-Logik ausgelagert aus MainActivity&#10;        val fixStatus = when {&#10;            lastGoodLocation == null -&gt; &quot;no GPS fix&quot;&#10;            System.currentTimeMillis() - lastGoodLocation.time &gt; 60_000 -&gt; &quot;GPS fix old&quot;&#10;            else -&gt; &quot;GPS fix&quot;&#10;        }&#10;        val gpsStatus = getGpsStatus()&#10;        val neutralColor = &quot;#FFFFFF&quot;&#10;        val fixColor = String.format(&quot;#%06X&quot;, 0xFFFFFF and getFixColor(fixStatus))&#10;        // AOS/LOS calculation&#10;        val aosLos = if (lastGoodLocation != null &amp;&amp; tle1 != null &amp;&amp; tle2 != null) {&#10;            val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;            val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;            if (epoch != null) {&#10;                val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, utcNow, epoch)&#10;                val elev = pos?.let { SatelliteMathHelper.calculateElevation(&#10;                    lastGoodLocation.latitude,&#10;                    lastGoodLocation.longitude,&#10;                    lastGoodLocation.altitude,&#10;                    it.lat, it.lon, it.alt&#10;                ) } ?: 0.0&#10;                if (elev &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            } else {&#10;                &quot;--&quot;&#10;            }&#10;        } else {&#10;            &quot;--&quot;&#10;        }&#10;        val text = &quot;&quot;&quot;&#10;            &lt;font color='$neutralColor'&gt;AOS/LOS: $aosLos&lt;br&gt;Distance: -- km&lt;br&gt;Speed: -- km/h&lt;br&gt;&lt;/font&gt;&#10;            &lt;font color='$fixColor'&gt;$fixStatus&lt;/font&gt; &lt;font color='$neutralColor'&gt;$gpsStatus&lt;/font&gt;&#10;        &quot;&quot;&quot;.trimIndent()&#10;        overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;    }&#10;&#10;    fun getFixColor(fixStatus: String): Int {&#10;        return when (fixStatus) {&#10;            &quot;GPS fix&quot; -&gt; 0x00FF00 // Grün&#10;            &quot;GPS fix old&quot; -&gt; 0xFFFF00 // Gelb&#10;            &quot;no GPS fix&quot;, &quot;no Fix&quot; -&gt; 0xFF0000 // Rot&#10;            else -&gt; 0xFFFFFF // Weiß&#10;        }&#10;    }&#10;&#10;    fun getGpsStatus(): String {&#10;        // Hier kann die Logik für den GPS-Status angepasst werden&#10;        // Beispiel: Einfacher Dummy-Status&#10;        return &quot;Status unbekannt&quot;&#10;    }&#10;&#10;    fun updateSatelliteDirectionOverlay(&#10;        overlayText: TextView,&#10;        location: Location,&#10;        satPos: Sgp4Util.SatPos?,&#10;        satName: String?,&#10;        currentAzimuth: Double,&#10;        currentPitch: Double,&#10;        tle1: String,&#10;        tle2: String&#10;    ) {&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        if (satPos == null) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;No valid satellite data. Please select a satellite.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        try {&#10;            val azimuth = SatelliteMathHelper.calculateAzimuth(location.latitude, location.longitude, satPos.lat, satPos.lon)&#10;            val elevation = SatelliteMathHelper.calculateElevation(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            val distance = SatelliteMathHelper.calculateDistance(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            var speed = 0.0&#10;            val dtSec = 10.0&#10;            val now = Date()&#10;            val futureDate = Date(now.time + (dtSec * 1000).toLong())&#10;            val posFut = SatelliteMathHelper.getSatellitePosition(satName ?: &quot;&quot;, &quot;&quot;, futureDate, now)&#10;            if (posFut != null) {&#10;                val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(location, satPos, posFut, dtSec)&#10;                speed = radialSpeed / 1000.0 // km/s&#10;            }&#10;            val fixStatus = if (location.hasAccuracy() &amp;&amp; location.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - location.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;            val aosLos = if (elevation &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            val azStr = String.format(Locale.US, &quot;%.1f°&quot;, azimuth)&#10;            val elStr = String.format(Locale.US, &quot;%.1f°&quot;, elevation)&#10;            val distStr = String.format(Locale.US, &quot;%.1f km&quot;, distance)&#10;            val speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, speed*1000.0)&#10;            val latDir = if (satPos.lat &gt;= 0) &quot;N&quot; else &quot;S&quot;&#10;            val lonDir = if (satPos.lon &gt;= 0) &quot;E&quot; else &quot;W&quot;&#10;            val latAbs = abs(satPos.lat)&#10;            val lonAbs = abs(satPos.lon)&#10;            val satPosInfo = &quot;Lat: %.1f° %s, Lon: %.1f° %s, Height: %.0f Km&quot;.format(latAbs, latDir, lonAbs, lonDir, satPos.alt/1000.0)&#10;            val text = &quot;&quot;&quot;&#10;                Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                Distance: $distStr km, Speed: $speedStr&lt;br&gt;&#10;                Fix: $fixStatus&lt;br&gt;&#10;                Status: $aosLos&lt;br&gt;&#10;                Sat-Pos: $satPosInfo&lt;br&gt;&#10;                Satellite: ${satName ?: &quot;(no name)&quot;}&#10;            &quot;&quot;&quot;.trimIndent()&#10;            overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(overlayText.context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = overlayText.context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(overlayText.context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            overlayText.context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob ein TLE-String gültig ist (mind. 69 Zeichen, nicht nur Leerzeichen, nicht null).&#10;     */&#10;    fun isValidTleLine(line: String?): Boolean {&#10;        return !line.isNullOrBlank() &amp;&amp; line.trim().length &gt;= 69&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.location.LocationManager&#10;import android.text.Html&#10;import android.util.Log&#10;import android.widget.TextView&#10;import java.util.*&#10;import kotlin.math.abs&#10;&#10;object OverlayViewHelper {&#10;    fun updateOverlay(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        satName: String?,&#10;        lastGoodLocation: Location?,&#10;        aosTime: Long,&#10;        losTime: Long&#10;    ) {&#10;        val satDisplay = satName ?: &quot;(no satellite selected)&quot;&#10;        val loc = lastGoodLocation ?: run {&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                val locTmp = Location(LocationManager.GPS_PROVIDER)&#10;                locTmp.latitude = lat&#10;                locTmp.longitude = lon&#10;                locTmp.altitude = alt&#10;                locTmp.time = time&#10;                locTmp&#10;            } else null&#10;        }&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        // ab hier sind tle1 und tle2 garantiert nicht null und gültig&#10;        val tle1Str = tle1!!&#10;        val tle2Str = tle2!!&#10;        var aosLos = &quot;--&quot;&#10;        var satPos: Sgp4Util.SatPos? = null&#10;        var epoch: Date? = null&#10;        var distance: Double?&#10;        var speedStr = &quot;--&quot;&#10;        val satPosInfo = &quot;Sat-Pos: --&quot;&#10;        try {&#10;            epoch = TleHelper.extractEpochFromTle(tle1Str)&#10;            val utcNow = Date() // aktuelle Zeit verwenden&#10;            if (loc != null &amp;&amp; epoch != null) {&#10;                satPos = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, utcNow, epoch)&#10;                // Debug: Prüfe, ob satPos sich bei Satellitenwechsel ändert&#10;                Log.d(&quot;SatFinder1&quot;, &quot;Name: $satName satPos: $satPos, tle1: $tle1Str, tle2: $tle2Str, utcNow: $utcNow, epoch: $epoch&quot;)&#10;                val elev = satPos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                val az = satPos?.let { SatelliteMathHelper.calculateAzimuth(loc.latitude, loc.longitude, it.lat, it.lon) }&#10;                // Debug: Prüfe, ob elev/az sich bei Satellitenwechsel ändern&#10;                Log.d(&quot;SatFinder1&quot;, &quot;elev: $elev, az: $az&quot;)&#10;                distance = satPos?.let { SatelliteMathHelper.calculateDistance(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                aosLos = if (elev != null &amp;&amp; elev &gt; 0.0) &quot;AOS&quot; else &quot;LOS&quot;&#10;                // Always calculate speed&#10;                val nowDate = utcNow&#10;                val dtSec = 10.0&#10;                val futureDate = Date(nowDate.time + (dtSec * 1000).toLong())&#10;                val satPosFuture = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, futureDate, epoch)&#10;                if (satPos != null &amp;&amp; satPosFuture != null) {&#10;                    val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(loc, satPos, satPosFuture, dtSec)&#10;                    Log.d(&quot;SatFinder3&quot;, &quot;Speed-Berechnung: now=(${satPos.lat},${satPos.lon},${satPos.alt}), future=(${satPosFuture.lat},${satPosFuture.lon},${satPosFuture.alt}), dtSec=$dtSec, speed=$radialSpeed&quot;)&#10;                    speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, radialSpeed)&#10;                }&#10;                // Round values and adjust units&#10;                val azStr = az?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val elStr = elev?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val distStr = distance?.let { String.format(Locale.US, &quot;%.1f km&quot;, it/1000.0) } ?: &quot;--&quot;&#10;                val speedStrRounded = speedStr&#10;                // Calculate next AOS time if LOS&#10;                var nextAosStr = &quot;--&quot;&#10;                if (aosLos == &quot;LOS&quot; &amp;&amp; tle1 != null &amp;&amp; tle2 != null &amp;&amp; loc != null &amp;&amp; epoch != null) {&#10;                    try {&#10;                        val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;                        var testTime: Date&#10;                        val maxSearch = 24 * 3600 // max 24h search&#10;                        for (i in 1..maxSearch step 10) { // 10s steps&#10;                            testTime = Date(utcNow.time + i * 1000L)&#10;                            val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, testTime, epoch)&#10;                            val elevTest = pos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) } ?: 0.0&#10;                            if (elevTest &gt; 0) {&#10;                                nextAosStr = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.US).format(testTime)&#10;                                break&#10;                            }&#10;                        }&#10;                    } catch (_: Exception) {}&#10;                }&#10;                // AOS: Show time only when LOS&#10;                val fixStatus = if (loc != null &amp;&amp; loc.hasAccuracy() &amp;&amp; loc.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - loc.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;                val aosLosStr = if (aosLos == &quot;LOS&quot; &amp;&amp; nextAosStr != &quot;--&quot;) &quot;LOS (next rise: $nextAosStr)&quot; else aosLos&#10;                val text = &quot;&quot;&quot;&#10;                    Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                    Distance: $distStr, Speed: $speedStrRounded&lt;br&gt;&#10;                    Fix: $fixStatus&lt;br&gt;&#10;                    Status: $aosLosStr&lt;br&gt;&#10;                    $satPosInfo&lt;br&gt;&#10;                    Satellite: $satDisplay&#10;                &quot;&quot;&quot;.trimIndent()&#10;                overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;            }&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    fun updateFixStatus(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        lastGoodLocation: Location?,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        getFixColor: (String) -&gt; Int,&#10;        getGpsStatus: () -&gt; String&#10;    ) {&#10;        // FixStatus-Logik ausgelagert aus MainActivity&#10;        val fixStatus = when {&#10;            lastGoodLocation == null -&gt; &quot;no GPS fix&quot;&#10;            System.currentTimeMillis() - lastGoodLocation.time &gt; 60_000 -&gt; &quot;GPS fix old&quot;&#10;            else -&gt; &quot;GPS fix&quot;&#10;        }&#10;        val gpsStatus = getGpsStatus()&#10;        val neutralColor = &quot;#FFFFFF&quot;&#10;        val fixColor = String.format(&quot;#%06X&quot;, 0xFFFFFF and getFixColor(fixStatus))&#10;        // AOS/LOS calculation&#10;        val aosLos = if (lastGoodLocation != null &amp;&amp; tle1 != null &amp;&amp; tle2 != null) {&#10;            val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;            val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;            if (epoch != null) {&#10;                val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, utcNow, epoch)&#10;                val elev = pos?.let { SatelliteMathHelper.calculateElevation(&#10;                    lastGoodLocation.latitude,&#10;                    lastGoodLocation.longitude,&#10;                    lastGoodLocation.altitude,&#10;                    it.lat, it.lon, it.alt&#10;                ) } ?: 0.0&#10;                if (elev &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            } else {&#10;                &quot;--&quot;&#10;            }&#10;        } else {&#10;            &quot;--&quot;&#10;        }&#10;        val text = &quot;&quot;&quot;&#10;            &lt;font color='$neutralColor'&gt;AOS/LOS: $aosLos&lt;br&gt;Distance: -- km&lt;br&gt;Speed: -- km/h&lt;br&gt;&lt;/font&gt;&#10;            &lt;font color='$fixColor'&gt;$fixStatus&lt;/font&gt; &lt;font color='$neutralColor'&gt;$gpsStatus&lt;/font&gt;&#10;        &quot;&quot;&quot;.trimIndent()&#10;        overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;    }&#10;&#10;    fun getFixColor(fixStatus: String): Int {&#10;        return when (fixStatus) {&#10;            &quot;GPS fix&quot; -&gt; 0x00FF00 // Grün&#10;            &quot;GPS fix old&quot; -&gt; 0xFFFF00 // Gelb&#10;            &quot;no GPS fix&quot;, &quot;no Fix&quot; -&gt; 0xFF0000 // Rot&#10;            else -&gt; 0xFFFFFF // Weiß&#10;        }&#10;    }&#10;&#10;    fun getGpsStatus(): String {&#10;        // Hier kann die Logik für den GPS-Status angepasst werden&#10;        // Beispiel: Einfacher Dummy-Status&#10;        return &quot;Status unbekannt&quot;&#10;    }&#10;&#10;    fun updateSatelliteDirectionOverlay(&#10;        overlayText: TextView,&#10;        location: Location,&#10;        satPos: Sgp4Util.SatPos?,&#10;        satName: String?,&#10;        currentAzimuth: Double,&#10;        currentPitch: Double,&#10;        tle1: String,&#10;        tle2: String&#10;    ) {&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        if (satPos == null) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;No valid satellite data. Please select a satellite.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        try {&#10;            val azimuth = SatelliteMathHelper.calculateAzimuth(location.latitude, location.longitude, satPos.lat, satPos.lon)&#10;            val elevation = SatelliteMathHelper.calculateElevation(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            val distance = SatelliteMathHelper.calculateDistance(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            var speed = 0.0&#10;            val dtSec = 10.0&#10;            val now = Date()&#10;            val futureDate = Date(now.time + (dtSec * 1000).toLong())&#10;            val posFut = SatelliteMathHelper.getSatellitePosition(satName ?: &quot;&quot;, &quot;&quot;, futureDate, now)&#10;            if (posFut != null) {&#10;                val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(location, satPos, posFut, dtSec)&#10;                speed = radialSpeed / 1000.0 // km/s&#10;            }&#10;            val fixStatus = if (location.hasAccuracy() &amp;&amp; location.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - location.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;            val aosLos = if (elevation &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            val azStr = String.format(Locale.US, &quot;%.1f°&quot;, azimuth)&#10;            val elStr = String.format(Locale.US, &quot;%.1f°&quot;, elevation)&#10;            val distStr = String.format(Locale.US, &quot;%.1f km&quot;, distance)&#10;            val speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, speed*1000.0)&#10;            val latDir = if (satPos.lat &gt;= 0) &quot;N&quot; else &quot;S&quot;&#10;            val lonDir = if (satPos.lon &gt;= 0) &quot;E&quot; else &quot;W&quot;&#10;            val latAbs = abs(satPos.lat)&#10;            val lonAbs = abs(satPos.lon)&#10;            val satPosInfo = &quot;Lat: %.1f° %s, Lon: %.1f° %s, Height: %.0f Km&quot;.format(latAbs, latDir, lonAbs, lonDir, satPos.alt/1000.0)&#10;            val text = &quot;&quot;&quot;&#10;                Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                Distance: $distStr km, Speed: $speedStr&lt;br&gt;&#10;                Fix: $fixStatus&lt;br&gt;&#10;                Status: $aosLos&lt;br&gt;&#10;                Sat-Pos: $satPosInfo&lt;br&gt;&#10;                Satellite: ${satName ?: &quot;(no name)&quot;}&#10;            &quot;&quot;&quot;.trimIndent()&#10;            overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(overlayText.context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = overlayText.context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(overlayText.context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            overlayText.context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob ein TLE-String gültig ist (mind. 69 Zeichen, nicht nur Leerzeichen, nicht null).&#10;     */&#10;    fun isValidTleLine(line: String?): Boolean {&#10;        return !line.isNullOrBlank() &amp;&amp; line.trim().length &gt;= 69&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;object PreferencesHelper {&#10;    fun saveLocation(context: Context, location: Location) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putFloat(&quot;fix_lat&quot;, location.latitude.toFloat())&#10;            putFloat(&quot;fix_lon&quot;, location.longitude.toFloat())&#10;            putFloat(&quot;fix_alt&quot;, location.altitude.toFloat())&#10;            putLong(&quot;fix_time&quot;, location.time)&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadLocation(context: Context): Location? {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;            val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;            val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;            val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;            val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;            val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;            loc.latitude = lat&#10;            loc.longitude = lon&#10;            loc.altitude = alt&#10;            loc.time = time&#10;            loc&#10;        } else null&#10;            putFloat(&quot;last_satAltMeters&quot;, satAltMeters.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadSatelliteData(context: Context): Triple&lt;String?, String?, String?&gt; {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        val tle1 = prefs.getString(&quot;last_tle1&quot;, null)&#10;        val tle2 = prefs.getString(&quot;last_tle2&quot;, null)&#10;        val satName = prefs.getString(&quot;last_satName&quot;, null)&#10;        return Triple(tle1, tle2, satName)&#10;    }&#10;}&#10;&#10;object ActivityResultHelper {&#10;    fun handleSatelliteSelectionResult(&#10;        context: Context,&#10;        val tle1 = prefs.getString(&quot;last_tle1&quot;, null)&#10;        val tle2 = prefs.getString(&quot;last_tle2&quot;, null)&#10;        val satName = prefs.getString(&quot;last_satName&quot;, null)&#10;        return Triple(tle1, tle2, satName)&#10;        val satName = data.getStringExtra(&quot;satName&quot;)&#10;        val periodMin = data.getDoubleExtra(&quot;periodMin&quot;, 92.0)&#10;        val inclination = data.getDoubleExtra(&quot;inclination&quot;, 51.6)&#10;        val heightKm = data.getDoubleExtra(&quot;heightKm&quot;, 420.0)&#10;        val aosTime = data.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losTime = data.getLongExtra(&quot;los&quot;, -1L)&#10;        onUpdate(tle1, tle2, satName, satLat, satLon, satAltMeters, periodMin, inclination, heightKm, aosTime, losTime)&#10;        PreferencesHelper.saveSatelliteData(context, tle1, tle2, satName, satLat, satLon, satAltMeters)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;import android.util.Log&#10;&#10;object PreferencesHelper {&#10;    fun saveLocation(context: Context, location: Location) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putFloat(&quot;fix_lat&quot;, location.latitude.toFloat())&#10;            putFloat(&quot;fix_lon&quot;, location.longitude.toFloat())&#10;            putFloat(&quot;fix_alt&quot;, location.altitude.toFloat())&#10;            putLong(&quot;fix_time&quot;, location.time)&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadLocation(context: Context): Location? {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                if (lat == 0.0 &amp;&amp; lon == 0.0) {&#10;                    Log.w(&quot;PreferencesHelper&quot;, &quot;Location in Preferences ist 0/0 – wird ignoriert.&quot;)&#10;                    return null&#10;                }&#10;                val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;                loc.latitude = lat&#10;                loc.longitude = lon&#10;                loc.altitude = alt&#10;                loc.time = time&#10;                loc&#10;            } else null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Location aus Preferences&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    fun saveSatelliteData(context: Context, tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putString(&quot;last_tle1&quot;, tle1)&#10;            putString(&quot;last_tle2&quot;, tle2)&#10;            putString(&quot;last_satName&quot;, satName)&#10;            putFloat(&quot;last_satLat&quot;, satLat.toFloat())&#10;            putFloat(&quot;last_satLon&quot;, satLon.toFloat())&#10;            putFloat(&quot;last_satAltMeters&quot;, satAltMeters.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadSatelliteData(context: Context): Triple&lt;String?, String?, String?&gt; {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            val tle1 = prefs.getString(&quot;last_tle1&quot;, null)&#10;            val tle2 = prefs.getString(&quot;last_tle2&quot;, null)&#10;            val satName = prefs.getString(&quot;last_satName&quot;, null)&#10;            Triple(tle1, tle2, satName)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Satellitendaten aus Preferences&quot;, e)&#10;            Triple(null, null, null)&#10;        }&#10;    }&#10;}&#10;&#10;object ActivityResultHelper {&#10;    fun handleSatelliteSelectionResult(&#10;        context: Context,&#10;        data: Intent?,&#10;        onUpdate: (tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double, periodMin: Double, inclination: Double, heightKm: Double, aosTime: Long, losTime: Long) -&gt; Unit&#10;    ) {&#10;        if (data == null) return&#10;        val satLat = data.getDoubleExtra(&quot;satLat&quot;, 0.0)&#10;        val satLon = data.getDoubleExtra(&quot;satLon&quot;, 0.0)&#10;        val satAltMeters = data.getDoubleExtra(&quot;satAlt&quot;, 0.0)&#10;        val tle1 = data.getStringExtra(&quot;tle1&quot;)&#10;        val tle2 = data.getStringExtra(&quot;tle2&quot;)&#10;        val satName = data.getStringExtra(&quot;satName&quot;)&#10;        val periodMin = data.getDoubleExtra(&quot;periodMin&quot;, 92.0)&#10;        val inclination = data.getDoubleExtra(&quot;inclination&quot;, 51.6)&#10;        val heightKm = data.getDoubleExtra(&quot;heightKm&quot;, 420.0)&#10;        val aosTime = data.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losTime = data.getLongExtra(&quot;los&quot;, -1L)&#10;        onUpdate(tle1, tle2, satName, satLat, satLon, satAltMeters, periodMin, inclination, heightKm, aosTime, losTime)&#10;        PreferencesHelper.saveSatelliteData(context, tle1, tle2, satName, satLat, satLon, satAltMeters)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            return null&#10;        }&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.hardware.SensorManager&#10;import kotlin.math.*&#10;object SensorHelper {&#10;    /**&#10;     * Extracts azimuth and pitch from a rotation vector event.&#10;     * @param event The SensorEvent (rotation vector)&#10;     * @return Pair(azimuth, pitch) in degrees&#10;     */&#10;    fun getAzimuthAndPitch(event: SensorEvent): Pair&lt;Double, Double&gt; {&#10;        val rotationMatrix = FloatArray(9)&#10;        SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;        val orientation = FloatArray(3)&#10;        SensorManager.getOrientation(rotationMatrix, orientation)&#10;        val azimuth = (Math.toDegrees(orientation[0].toDouble()) + 360) % 360&#10;        val pitch = Math.toDegrees(orientation[1].toDouble())&#10;        return Pair(azimuth, pitch)&#10;    }&#10;&#10;    /**&#10;     * Calculates the device's look elevation (line of sight relative to horizon).&#10;     * @param azimuth Current azimuth in degrees&#10;     * @param pitch Current pitch in degrees&#10;     * @return Elevation in degrees&#10;     */&#10;    fun getDeviceLookElevation(azimuth: Double, pitch: Double): Double {&#10;        val azRad = Math.toRadians(azimuth)&#10;        val pitchRad = Math.toRadians(pitch)&#10;        val x = cos(pitchRad) * sin(azRad)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val z = sin(pitchRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorManager&#10;import android.content.pm.PackageManager&#10;import kotlin.math.*&#10;&#10;object SensorHelper {&#10;    /**&#10;     * Extracts azimuth and pitch from a rotation vector event.&#10;     * @param event The SensorEvent (rotation vector)&#10;     * @return Pair(azimuth, pitch) in degrees&#10;     */&#10;    fun getAzimuthAndPitch(event: SensorEvent): Pair&lt;Double, Double&gt; {&#10;        val rotationMatrix = FloatArray(9)&#10;        SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;        val orientation = FloatArray(3)&#10;        SensorManager.getOrientation(rotationMatrix, orientation)&#10;        val azimuth = (Math.toDegrees(orientation[0].toDouble()) + 360) % 360&#10;        val pitch = Math.toDegrees(orientation[1].toDouble())&#10;        return Pair(azimuth, pitch)&#10;    }&#10;&#10;    /**&#10;     * Calculates the device's look elevation (line of sight relative to horizon).&#10;     * @param azimuth Current azimuth in degrees&#10;     * @param pitch Current pitch in degrees&#10;     * @return Elevation in degrees&#10;     */&#10;    fun getDeviceLookElevation(azimuth: Double, pitch: Double): Double {&#10;        val azRad = Math.toRadians(azimuth)&#10;        val pitchRad = Math.toRadians(pitch)&#10;        val x = cos(pitchRad) * sin(azRad)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val z = sin(pitchRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;object PermissionHelper {&#10;    /**&#10;     * Checks if the given permission is granted.&#10;     * @param context The context&#10;     * @param permission The permission string (e.g. Manifest.permission.ACCESS_FINE_LOCATION)&#10;     * @return true if granted, false otherwise&#10;     */&#10;    fun isPermissionGranted(context: Context, permission: String): Boolean {&#10;        return androidx.core.content.ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * Handles the result of a permission request.&#10;     * @param requestCode The request code&#10;     * @param permissions The permissions array&#10;     * @param grantResults The grant results array&#10;     * @param onGranted Callback if granted&#10;     * @param onDenied Callback if denied&#10;     */&#10;    fun handlePermissionResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray,&#10;        expectedRequestCode: Int,&#10;        onGranted: () -&gt; Unit,&#10;        onDenied: () -&gt; Unit&#10;    ) {&#10;        if (requestCode == expectedRequestCode &amp;&amp; grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;            onGranted()&#10;        } else {&#10;            onDenied()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;!-- Google Map als Hintergrund --&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/map&quot;&#10;        android:name=&quot;com.google.android.gms.maps.SupportMapFragment&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot; /&gt;&#10;&#10;    &lt;!-- Azimut-Balken (blau) --&gt;&#10;    &lt;View&#10;        android:id=&quot;@+id/azimuthArrow&quot;&#10;        android:layout_width=&quot;60dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:background=&quot;@drawable/arrow_horizontal&quot;&#10;        android:layout_gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;!-- Elevation-Balken (rot) --&gt;&#10;    &lt;View&#10;        android:id=&quot;@+id/elevationArrow&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;60dp&quot;&#10;        android:background=&quot;@drawable/arrow_vertical&quot;&#10;        android:layout_gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;!-- Overlay --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:background=&quot;#66000000&quot;&#10;        android:padding=&quot;20dp&quot;&#10;        android:layout_gravity=&quot;top|center_horizontal&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/overlayText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;AOS/LOS: -- / --\nDistance: -- km\nSpeed: -- km/h&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:textSize=&quot;20sp&quot;&#10;            android:lineSpacingExtra=&quot;6dp&quot;&#10;            android:gravity=&quot;center_horizontal&quot; /&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/selectSatelliteButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;@string/SelectSat&quot;&#10;        android:layout_gravity=&quot;bottom|center_horizontal&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&lt;/FrameLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout&#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;!-- Google Map als Hintergrund --&gt;&#10;    &lt;fragment&#10;        android:id=&quot;@+id/map&quot;&#10;        android:name=&quot;com.google.android.gms.maps.SupportMapFragment&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;match_parent&quot; /&gt;&#10;&#10;    &lt;!-- Azimut-Balken (blau) --&gt;&#10;    &lt;View&#10;        android:id=&quot;@+id/azimuthArrow&quot;&#10;        android:layout_width=&quot;60dp&quot;&#10;        android:layout_height=&quot;32dp&quot;&#10;        android:background=&quot;@drawable/arrow_horizontal&quot;&#10;        android:layout_gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;!-- Elevation-Balken (rot) --&gt;&#10;    &lt;View&#10;        android:id=&quot;@+id/elevationArrow&quot;&#10;        android:layout_width=&quot;32dp&quot;&#10;        android:layout_height=&quot;60dp&quot;&#10;        android:background=&quot;@drawable/arrow_vertical&quot;&#10;        android:layout_gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;!-- Overlay --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:background=&quot;#66000000&quot;&#10;        android:padding=&quot;20dp&quot;&#10;        android:layout_gravity=&quot;top|center_horizontal&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/overlayText&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;AOS/LOS: -- / --\nDistance: -- km\nSpeed: -- km/h&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:textSize=&quot;20sp&quot;&#10;            android:lineSpacingExtra=&quot;6dp&quot;&#10;            android:gravity=&quot;center_horizontal&quot; /&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Button --&gt;&#10;    &lt;Button&#10;        android:id=&quot;@+id/selectSatelliteButton&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;@string/SelectSat&quot;&#10;        android:layout_gravity=&quot;bottom|center_horizontal&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&lt;/FrameLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>