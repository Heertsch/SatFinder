<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md" />
              <option name="updatedContent" value="# SatFinder Build Instructions&#10;&#10;## Voraussetzungen&#10;&#10;1. Android Studio mit NDK-Unterstützung&#10;2. CMake (Version 3.10.2 oder höher)&#10;3. Android NDK (Version 26.1.10909125 oder kompatibel)&#10;&#10;## Build-Setup&#10;&#10;### 1. Repository klonen&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd SatFinder&#10;```&#10;&#10;### 2. Android Studio Setup&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Stellen Sie sicher, dass die folgenden SDK-Komponenten installiert sind:&#10;  - Android SDK Platform 35&#10;  - Android NDK (Version 26.1.10909125)&#10;  - CMake&#10;&#10;### 3. Native Dependencies&#10;Das Projekt enthält die SGP4-Bibliothek als Teil des Repositorys im `sgp4/` Verzeichnis. &#10;Keine zusätzlichen Downloads erforderlich.&#10;&#10;### 4. Build&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Gradle sollte automatisch synchronisieren&#10;- Build &gt; Make Project&#10;&#10;## Fehlerbehebung&#10;&#10;### CMake-Fehler beim Build&#10;Wenn CMake die SGP4-Quellen nicht finden kann:&#10;1. Überprüfen Sie, dass das `sgp4/libsgp4/` Verzeichnis existiert&#10;2. Führen Sie &quot;Clean Project&quot; aus und bauen Sie erneut&#10;&#10;### NDK-Version-Konflikte&#10;Falls NDK-Versionskonflikte auftreten, aktualisieren Sie die NDK-Version in `app/build.gradle.kts`:&#10;```kotlin&#10;ndkVersion = &quot;26.1.10909125&quot;&#10;```&#10;&#10;## Projektstruktur&#10;```&#10;SatFinder/&#10;├── app/&#10;│   ├── src/main/cpp/          # Native C++ Code&#10;│   │   ├── CMakeLists.txt     # CMake Build-Konfiguration&#10;│   │   └── sgp4_jni.cpp       # JNI-Interface&#10;│   └── build.gradle.kts       # Android Build-Konfiguration&#10;├── sgp4/                      # SGP4-Bibliothek (enthalten)&#10;│   └── libsgp4/              # SGP4-Quellcode&#10;└── BUILD_INSTRUCTIONS.md     # Diese Datei&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.10.2)&#10;&#10;project(sgp4native)&#10;&#10;# SGP4-Quellen direkt einbinden&#10;set(SGP4_SRC&#10;    ../../../../sgp4/libsgp4/CoordGeodetic.cc&#10;    ../../../../sgp4/libsgp4/CoordTopocentric.cc&#10;    ../../../../sgp4/libsgp4/DateTime.cc&#10;    ../../../../sgp4/libsgp4/DecayedException.cc&#10;    ../../../../sgp4/libsgp4/Eci.cc&#10;    ../../../../sgp4/libsgp4/Globals.cc&#10;    ../../../../sgp4/libsgp4/Observer.cc&#10;    ../../../../sgp4/libsgp4/OrbitalElements.cc&#10;    ../../../../sgp4/libsgp4/SatelliteException.cc&#10;    ../../../../sgp4/libsgp4/SGP4.cc&#10;    ../../../../sgp4/libsgp4/SolarPosition.cc&#10;    ../../../../sgp4/libsgp4/TimeSpan.cc&#10;    ../../../../sgp4/libsgp4/Tle.cc&#10;    ../../../../sgp4/libsgp4/TleException.cc&#10;    ../../../../sgp4/libsgp4/Util.cc&#10;    ../../../../sgp4/libsgp4/Vector.cc&#10;)&#10;&#10;# JNI-Quellen&#10;set(SGP4_JNI_SRC sgp4_jni.cpp)&#10;&#10;# Erzeuge die native Bibliothek&#10;add_library(sgp4native SHARED ${SGP4_JNI_SRC} ${SGP4_SRC})&#10;#set_target_properties(sgp4native PROPERTIES LINK_FLAGS &quot;-Wl,--max-page-size=16384&quot;)&#10;# Include-Pfade für JNI und SGP4&#10;include_directories(&#10;    ../../../../sgp4/libsgp4&#10;    ../../../../sgp4/libsgp4/include&#10;    ../../../../sgp4/libsgp4/include&#10;    ${CMAKE_SOURCE_DIR}&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.10.2)&#13;&#10;&#13;&#10;project(sgp4native)&#13;&#10;&#13;&#10;# SGP4-Quellen aus dem Projekt-Repository&#13;&#10;set(SGP4_SRC&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/CoordGeodetic.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/CoordTopocentric.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/DateTime.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/DecayedException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Eci.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Globals.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Observer.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/OrbitalElements.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SatelliteException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SGP4.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SolarPosition.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/TimeSpan.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Tle.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/TleException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Util.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Vector.cc&#13;&#10;)&#13;&#10;&#13;&#10;# JNI-Quellen&#13;&#10;set(SGP4_JNI_SRC sgp4_jni.cpp)&#13;&#10;&#13;&#10;# Erzeuge die native Bibliothek&#13;&#10;add_library(sgp4native SHARED ${SGP4_JNI_SRC} ${SGP4_SRC})&#13;&#10;&#13;&#10;# Include-Pfade für JNI und SGP4&#13;&#10;include_directories(&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4&#13;&#10;    ${CMAKE_SOURCE_DIR}&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ActivityResultHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ActivityResultHelper.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ArrowViewHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ArrowViewHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.view.View&#10;import kotlin.math.abs&#10;&#10;object ArrowViewHelper {&#10;    fun updateAzimuthBar(azimuthArrow: View, error: Double) {&#10;        val parent = azimuthArrow.parent as View&#10;        val maxWidthPx = parent.width * 0.4 // Maximum 40% of parent width&#10;        val length = (abs(error) / 180.0 * maxWidthPx).toInt().coerceAtLeast((20 * azimuthArrow.resources.displayMetrics.density).toInt())&#10;&#10;        val layout = azimuthArrow.layoutParams&#10;        layout.width = length&#10;        layout.height = (16 * azimuthArrow.resources.displayMetrics.density).toInt()&#10;        azimuthArrow.layoutParams = layout&#10;&#10;        // Pivot at the blunt end (center of screen)&#10;        azimuthArrow.pivotX = 0f&#10;        azimuthArrow.pivotY = azimuthArrow.height / 2f&#10;        azimuthArrow.y = (parent.height / 2f) - (azimuthArrow.height / 2f)&#10;&#10;        // Error logic: Arrow points right if the smartphone is too far left (error &gt; 0), left if too far right (error &lt; 0)&#10;        if (error &gt; 0) {&#10;            // Arrow to the right&#10;            azimuthArrow.x = (parent.width / 2f)&#10;            azimuthArrow.rotation = 0f&#10;        } else {&#10;            // Arrow to the left&#10;            azimuthArrow.x = (parent.width / 2f) - length&#10;            azimuthArrow.rotation = 180f&#10;        }&#10;        azimuthArrow.bringToFront()&#10;    }&#10;&#10;    fun updateElevationBar(elevationArrow: View, error: Double) {&#10;        val parent = elevationArrow.parent as View&#10;        val minLengthPx = (20 * elevationArrow.resources.displayMetrics.density).toInt()&#10;        val maxHeightPx = if (parent.height &gt; 0) (parent.height.toDouble() * 0.3) else (minLengthPx * 2).toDouble()&#10;        // Arrow length: 0 if error=0, grows with |error|, but at least minLengthPx if error!=0&#10;        val length = if (abs(error) &lt; 1.0) 0 else (abs(error) / 90.0 * maxHeightPx).toInt().coerceAtLeast(minLengthPx)&#10;&#10;        val layout = elevationArrow.layoutParams&#10;        layout.width = (16 * elevationArrow.resources.displayMetrics.density).toInt()&#10;        layout.height = length&#10;        elevationArrow.layoutParams = layout&#10;&#10;        // Pivot at the blunt end (center of screen)&#10;        elevationArrow.pivotX = elevationArrow.width / 2f&#10;        elevationArrow.pivotY = 0f // Pivot at the blunt end&#10;        elevationArrow.x = (parent.width / 2f) - (elevationArrow.width / 2f)&#10;&#10;        if (length == 0) {&#10;            elevationArrow.visibility = View.INVISIBLE&#10;        } else {&#10;            elevationArrow.visibility = View.VISIBLE&#10;            // Pfeil zeigt standardmäßig nach UNTEN (rotation = 0°)&#10;            // rotation = 180° dreht ihn nach OBEN&#10;            // elError = elevation - deviceLookElevation (URSPRÜNGLICHE Berechnung!)&#10;            // Positiver error: Satellit höher als Handy zeigt -&gt; Pfeil nach oben (Handy nach oben neigen)&#10;            // Negativer error: Satellit niedriger als Handy zeigt -&gt; Pfeil nach unten (Handy nach unten neigen)&#10;            if (error &gt; 0) {&#10;                // Satellit ist höher als Handy zeigt -&gt; Pfeil nach oben&#10;                elevationArrow.y = (parent.height / 2f) - length&#10;                elevationArrow.rotation = 180f // 180° = Pfeil zeigt nach oben&#10;            } else {&#10;                // Satellit ist niedriger als Handy zeigt -&gt; Pfeil nach unten&#10;                elevationArrow.y = (parent.height / 2f)&#10;                elevationArrow.rotation = 0f // 0° = Pfeil zeigt nach unten&#10;            }&#10;            elevationArrow.bringToFront()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.view.View&#10;import kotlin.math.abs&#10;&#10;object ArrowViewHelper {&#10;    fun updateAzimuthBar(azimuthArrow: View, error: Double) {&#10;        val parent = azimuthArrow.parent as View&#10;        val maxWidthPx = parent.width * 0.4 // Maximum 40% of parent width&#10;        val length = (abs(error) / 180.0 * maxWidthPx).toInt().coerceAtLeast((20 * azimuthArrow.resources.displayMetrics.density).toInt())&#10;&#10;        val layout = azimuthArrow.layoutParams&#10;        layout.width = length&#10;        layout.height = (26 * azimuthArrow.resources.displayMetrics.density).toInt() // +10px dicker&#10;        azimuthArrow.layoutParams = layout&#10;&#10;        // Pivot at the tip (where it should point to center)&#10;        azimuthArrow.pivotX = length.toFloat() // Pivot an der Spitze&#10;        azimuthArrow.pivotY = azimuthArrow.height / 2f&#10;        azimuthArrow.y = (parent.height / 2f) - (azimuthArrow.height / 2f)&#10;&#10;        // Pfeilspitze soll zum Zentrum zeigen&#10;        if (error &gt; 0) {&#10;            // Handy zu weit links -&gt; Pfeil von links zum Zentrum (Spitze nach rechts)&#10;            azimuthArrow.x = (parent.width / 2f) - length&#10;            azimuthArrow.rotation = 0f // Original-Richtung nach rechts&#10;        } else {&#10;            // Handy zu weit rechts -&gt; Pfeil von rechts zum Zentrum (Spitze nach links)&#10;            azimuthArrow.x = (parent.width / 2f)&#10;            azimuthArrow.rotation = 180f // Gedreht nach links&#10;        }&#10;        azimuthArrow.bringToFront()&#10;    }&#10;&#10;    fun updateElevationBar(elevationArrow: View, error: Double) {&#10;        val parent = elevationArrow.parent as View&#10;        val minLengthPx = (20 * elevationArrow.resources.displayMetrics.density).toInt()&#10;        val maxHeightPx = if (parent.height &gt; 0) (parent.height.toDouble() * 0.3) else (minLengthPx * 2).toDouble()&#10;        // Arrow length: 0 if error=0, grows with |error|, but at least minLengthPx if error!=0&#10;        val length = if (abs(error) &lt; 1.0) 0 else (abs(error) / 90.0 * maxHeightPx).toInt().coerceAtLeast(minLengthPx)&#10;&#10;        val layout = elevationArrow.layoutParams&#10;        layout.width = (26 * elevationArrow.resources.displayMetrics.density).toInt() // +10px dicker&#10;        layout.height = length&#10;        elevationArrow.layoutParams = layout&#10;&#10;        // Pivot at the tip (where it should point to center)&#10;        elevationArrow.pivotX = elevationArrow.width / 2f&#10;        elevationArrow.pivotY = length.toFloat() // Pivot an der Spitze&#10;        elevationArrow.x = (parent.width / 2f) - (elevationArrow.width / 2f)&#10;&#10;        if (length == 0) {&#10;            elevationArrow.visibility = View.INVISIBLE&#10;        } else {&#10;            elevationArrow.visibility = View.VISIBLE&#10;            // Pfeilspitze soll zum Zentrum zeigen - Position and Rotation anpassen&#10;            if (error &gt; 0) {&#10;                // Satellit ist höher -&gt; Pfeil von unten zum Zentrum (Spitze nach oben)&#10;                elevationArrow.y = (parent.height / 2f) - length&#10;                elevationArrow.rotation = 0f // Original-Richtung nach unten, aber von unten positioniert&#10;            } else {&#10;                // Satellit ist niedriger -&gt; Pfeil von oben zum Zentrum (Spitze nach unten)&#10;                elevationArrow.y = (parent.height / 2f)&#10;                elevationArrow.rotation = 180f // Gedreht nach oben, aber von oben positioniert&#10;            }&#10;            elevationArrow.bringToFront()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.graphics.Color&#10;import android.location.Location&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;import com.google.android.gms.maps.model.CircleOptions&#10;import kotlin.math.*&#10;&#10;object MapHelper {&#10;    /**&#10;     * Centers the map on the given location and adds a marker.&#10;     * @param googleMap The GoogleMap instance (nullable)&#10;     * @param location The location to center and mark&#10;     */&#10;    fun updateMapPosition(googleMap: GoogleMap?, location: Location) {&#10;        if (googleMap == null) return&#10;        val pos = LatLng(location.latitude, location.longitude)&#10;        googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(pos, 0.5f))  // Noch kleinerer Zoom für bessere Übersicht&#10;        googleMap.clear()&#10;        googleMap.addMarker(MarkerOptions().position(pos).title(&quot;Present Position&quot;))&#10;    }&#10;&#10;    /**&#10;     * Berechnet den Empfangsradius eines Satelliten basierend auf Höhe und min. Elevationswinkel&#10;     * @param satelliteAltitudeKm Satellitenhöhe in km&#10;     * @param minElevationDegrees Minimaler Elevationswinkel in Grad (normalerweise 5-10°)&#10;     * @return Empfangsradius in Kilometern&#10;     */&#10;    fun calculateCoverageRadius(satelliteAltitudeKm: Double, minElevationDegrees: Double = 5.0): Double {&#10;        val earthRadiusKm = 6371.0 // Erdradius in km&#10;        val elevationRad = Math.toRadians(minElevationDegrees)&#10;&#10;        // Geometrische Berechnung des Sichtradius&#10;        val satelliteDistanceFromCenter = earthRadiusKm + satelliteAltitudeKm&#10;        val horizonAngle = acos(earthRadiusKm / satelliteDistanceFromCenter)&#10;        val maxAngle = horizonAngle - elevationRad&#10;&#10;        // Radius auf der Erdoberfläche&#10;        val coverageRadiusKm = earthRadiusKm * sin(maxAngle)&#10;&#10;        return max(0.0, coverageRadiusKm)&#10;    }&#10;&#10;    /**&#10;     * Adds a satellite coverage circle to the map&#10;     * @param googleMap The GoogleMap instance&#10;     * @param satelliteLat Satellite latitude&#10;     * @param satelliteLon Satellite longitude&#10;     * @param satelliteAltitudeKm Satellite altitude in km&#10;     * @param minElevationDegrees Minimum elevation angle (default 5°)&#10;     */&#10;    fun addSatelliteCoverage(&#10;        googleMap: GoogleMap?,&#10;        satelliteLat: Double,&#10;        satelliteLon: Double,&#10;        satelliteAltitudeKm: Double,&#10;        minElevationDegrees: Double = 5.0&#10;    ) {&#10;        if (googleMap == null) return&#10;&#10;        val satellitePos = LatLng(satelliteLat, satelliteLon)&#10;        val radiusKm = calculateCoverageRadius(satelliteAltitudeKm, minElevationDegrees)&#10;        val radiusMeters = radiusKm * 1000 // Convert to meters for Google Maps&#10;&#10;        // Add coverage circle - Google Maps handles Mercator distortion automatically&#10;        googleMap.addCircle(CircleOptions()&#10;            .center(satellitePos)&#10;            .radius(radiusMeters)&#10;            .strokeColor(Color.BLUE)&#10;            .strokeWidth(3f)&#10;            .fillColor(Color.argb(30, 0, 100, 255)) // Semi-transparent blue&#10;        )&#10;&#10;        // Add satellite marker&#10;        googleMap.addMarker(MarkerOptions()&#10;            .position(satellitePos)&#10;            .title(&quot;Satellite (${satelliteAltitudeKm.toInt()}km)&quot;)&#10;            .snippet(&quot;Coverage: ${radiusKm.toInt()}km radius&quot;))&#10;    }&#10;&#10;    /**&#10;     * Adds coverage for current satellite position from TLE data&#10;     * @param googleMap The GoogleMap instance&#10;     * @param satPos Satellite position (lat, lon, alt in meters)&#10;     */&#10;    fun addCurrentSatelliteCoverage(googleMap: GoogleMap?, satPos: Any) {&#10;        if (googleMap == null) return&#10;&#10;        // Extract lat, lon, alt from satPos object (assuming it has these properties)&#10;        try {&#10;            val latField = satPos::class.java.getDeclaredField(&quot;lat&quot;)&#10;            val lonField = satPos::class.java.getDeclaredField(&quot;lon&quot;)&#10;            val altField = satPos::class.java.getDeclaredField(&quot;alt&quot;)&#10;&#10;            latField.isAccessible = true&#10;            lonField.isAccessible = true&#10;            altField.isAccessible = true&#10;&#10;            val lat = latField.get(satPos) as Double&#10;            val lon = lonField.get(satPos) as Double&#10;            val altMeters = altField.get(satPos) as Double&#10;            val altKm = altMeters / 1000.0&#10;&#10;            addSatelliteCoverage(googleMap, lat, lon, altKm)&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;MapHelper&quot;, &quot;Error extracting satellite position: ${e.message}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.graphics.Color&#10;import android.location.Location&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;import com.google.android.gms.maps.model.CircleOptions&#10;import kotlin.math.*&#10;&#10;object MapHelper {&#10;    /**&#10;     * Centers the map on the given location and adds a marker.&#10;     * @param googleMap The GoogleMap instance (nullable)&#10;     * @param location The location to center and mark&#10;     */&#10;    fun updateMapPosition(googleMap: GoogleMap?, location: Location) {&#10;        if (googleMap == null) return&#10;        val pos = LatLng(location.latitude, location.longitude)&#10;        googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(pos, 0.5f))  // Noch kleinerer Zoom für bessere Übersicht&#10;        googleMap.clear()&#10;        googleMap.addMarker(MarkerOptions().position(pos).title(&quot;Present Position&quot;))&#10;    }&#10;&#10;    /**&#10;     * Berechnet den Empfangsradius eines Satelliten basierend auf Höhe und min. Elevationswinkel&#10;     * @param satelliteAltitudeKm Satellitenhöhe in km&#10;     * @param minElevationDegrees Minimaler Elevationswinkel in Grad (normalerweise 5-10°)&#10;     * @return Empfangsradius in Kilometern&#10;     */&#10;    fun calculateCoverageRadius(satelliteAltitudeKm: Double, minElevationDegrees: Double = 5.0): Double {&#10;        val earthRadiusKm = 6371.0 // Erdradius in km&#10;        val elevationRad = Math.toRadians(minElevationDegrees)&#10;&#10;        // Geometrische Berechnung des Sichtradius&#10;        val satelliteDistanceFromCenter = earthRadiusKm + satelliteAltitudeKm&#10;        val horizonAngle = acos(earthRadiusKm / satelliteDistanceFromCenter)&#10;        val maxAngle = horizonAngle - elevationRad&#10;&#10;        // Radius auf der Erdoberfläche&#10;        val coverageRadiusKm = earthRadiusKm * sin(maxAngle)&#10;&#10;        return max(0.0, coverageRadiusKm)&#10;    }&#10;&#10;    /**&#10;     * Adds a satellite coverage circle to the map&#10;     * @param googleMap The GoogleMap instance&#10;     * @param satelliteLat Satellite latitude&#10;     * @param satelliteLon Satellite longitude&#10;     * @param satelliteAltitudeKm Satellite altitude in km&#10;     * @param minElevationDegrees Minimum elevation angle (default 5°)&#10;     */&#10;    fun addSatelliteCoverage(&#10;        googleMap: GoogleMap?,&#10;        satelliteLat: Double,&#10;        satelliteLon: Double,&#10;        satelliteAltitudeKm: Double,&#10;        minElevationDegrees: Double = 5.0&#10;    ) {&#10;        if (googleMap == null) return&#10;&#10;        val satellitePos = LatLng(satelliteLat, satelliteLon)&#10;        val radiusKm = calculateCoverageRadius(satelliteAltitudeKm, minElevationDegrees)&#10;        val radiusMeters = radiusKm * 1000 // Convert to meters for Google Maps&#10;&#10;        // Add coverage circle - Google Maps handles Mercator distortion automatically&#10;        googleMap.addCircle(CircleOptions()&#10;            .center(satellitePos)&#10;            .radius(radiusMeters)&#10;            .strokeColor(Color.RED)&#10;            .strokeWidth(3f)&#10;            .fillColor(Color.TRANSPARENT) // Keine Füllung - nur Rand sichtbar&#10;        )&#10;&#10;        // Add satellite marker&#10;        googleMap.addMarker(MarkerOptions()&#10;            .position(satellitePos)&#10;            .title(&quot;Satellite (${satelliteAltitudeKm.toInt()}km)&quot;)&#10;            .snippet(&quot;Coverage: ${radiusKm.toInt()}km radius&quot;))&#10;    }&#10;&#10;    /**&#10;     * Adds coverage for current satellite position from TLE data&#10;     * @param googleMap The GoogleMap instance&#10;     * @param satPos Satellite position (lat, lon, alt in meters)&#10;     */&#10;    fun addCurrentSatelliteCoverage(googleMap: GoogleMap?, satPos: Any) {&#10;        if (googleMap == null) return&#10;&#10;        // Extract lat, lon, alt from satPos object (assuming it has these properties)&#10;        try {&#10;            val latField = satPos::class.java.getDeclaredField(&quot;lat&quot;)&#10;            val lonField = satPos::class.java.getDeclaredField(&quot;lon&quot;)&#10;            val altField = satPos::class.java.getDeclaredField(&quot;alt&quot;)&#10;&#10;            latField.isAccessible = true&#10;            lonField.isAccessible = true&#10;            altField.isAccessible = true&#10;&#10;            val lat = latField.get(satPos) as Double&#10;            val lon = lonField.get(satPos) as Double&#10;            val altMeters = altField.get(satPos) as Double&#10;            val altKm = altMeters / 1000.0&#10;&#10;            addSatelliteCoverage(googleMap, lat, lon, altKm)&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;MapHelper&quot;, &quot;Error extracting satellite position: ${e.message}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;            val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;            val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;            val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;            val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;            val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;            loc.latitude = lat&#10;            loc.longitude = lon&#10;            loc.altitude = alt&#10;            loc.time = time&#10;            loc&#10;        } else null&#10;        return Triple(tle1, tle2, satName)&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;import android.util.Log&#10;&#10;object PreferencesHelper {&#10;    fun saveLocation(context: Context, location: Location) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putFloat(&quot;fix_lat&quot;, location.latitude.toFloat())&#10;            putFloat(&quot;fix_lon&quot;, location.longitude.toFloat())&#10;            putFloat(&quot;fix_alt&quot;, location.altitude.toFloat())&#10;            putLong(&quot;fix_time&quot;, location.time)&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadLocation(context: Context): Location? {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                if (lat == 0.0 &amp;&amp; lon == 0.0) {&#10;                    Log.w(&quot;PreferencesHelper&quot;, &quot;Location in Preferences ist 0/0 – wird ignoriert.&quot;)&#10;                    return null&#10;                }&#10;                val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;                loc.latitude = lat&#10;                loc.longitude = lon&#10;                loc.altitude = alt&#10;                loc.time = time&#10;                loc&#10;            } else null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Location aus Preferences&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    fun saveSatelliteData(context: Context, tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putString(&quot;last_tle1&quot;, tle1)&#10;            putString(&quot;last_tle2&quot;, tle2)&#10;            putString(&quot;last_satName&quot;, satName)&#10;            putFloat(&quot;last_satLat&quot;, satLat.toFloat())&#10;            putFloat(&quot;last_satLon&quot;, satLon.toFloat())&#10;            putFloat(&quot;last_satAltMeters&quot;, satAltMeters.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadSatelliteData(context: Context): Triple&lt;String?, String?, String?&gt; {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            val tle1 = prefs.getString(&quot;last_tle1&quot;, null)&#10;            val tle2 = prefs.getString(&quot;last_tle2&quot;, null)&#10;            val satName = prefs.getString(&quot;last_satName&quot;, null)&#10;            Triple(tle1, tle2, satName)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Satellitendaten aus Preferences&quot;, e)&#10;            Triple(null, null, null)&#10;        }&#10;    }&#10;}&#10;&#10;object ActivityResultHelper {&#10;    fun handleSatelliteSelectionResult(&#10;        context: Context,&#10;        data: Intent?,&#10;        onUpdate: (tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double, periodMin: Double, inclination: Double, heightKm: Double, aosTime: Long, losTime: Long) -&gt; Unit&#10;    ) {&#10;        if (data == null) return&#10;        val satLat = data.getDoubleExtra(&quot;satLat&quot;, 0.0)&#10;        val satLon = data.getDoubleExtra(&quot;satLon&quot;, 0.0)&#10;        val satAltMeters = data.getDoubleExtra(&quot;satAlt&quot;, 0.0)&#10;        val tle1 = data.getStringExtra(&quot;tle1&quot;)&#10;        val tle2 = data.getStringExtra(&quot;tle2&quot;)&#10;        val satName = data.getStringExtra(&quot;satName&quot;)&#10;        val periodMin = data.getDoubleExtra(&quot;periodMin&quot;, 92.0)&#10;        val inclination = data.getDoubleExtra(&quot;inclination&quot;, 51.6)&#10;        val heightKm = data.getDoubleExtra(&quot;heightKm&quot;, 420.0)&#10;        val aosTime = data.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losTime = data.getLongExtra(&quot;los&quot;, -1L)&#10;        onUpdate(tle1, tle2, satName, satLat, satLon, satAltMeters, periodMin, inclination, heightKm, aosTime, losTime)&#10;        PreferencesHelper.saveSatelliteData(context, tle1, tle2, satName, satLat, satLon, satAltMeters)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            return null&#10;        }&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;        val pitchRad = Math.toRadians(pitch)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorManager&#10;import android.content.pm.PackageManager&#10;import kotlin.math.*&#10;&#10;object SensorHelper {&#10;    /**&#10;     * Extracts azimuth and pitch from a rotation vector event.&#10;     * @param event The SensorEvent (rotation vector)&#10;     * @return Pair(azimuth, pitch) in degrees&#10;     */&#10;    fun getAzimuthAndPitch(event: SensorEvent): Pair&lt;Double, Double&gt; {&#10;        val rotationMatrix = FloatArray(9)&#10;        SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;        val orientation = FloatArray(3)&#10;        SensorManager.getOrientation(rotationMatrix, orientation)&#10;        val azimuthRaw = (Math.toDegrees(orientation[0].toDouble()) + 360) % 360&#10;        val azimuth = (azimuthRaw - 90 + 360) % 360  // Korrektur um -90° für Portrait-Modus&#10;        val pitch = Math.toDegrees(orientation[1].toDouble())&#10;        return Pair(azimuth, pitch)&#10;    }&#10;&#10;    /**&#10;     * Calculates the device's look elevation (line of sight relative to horizon).&#10;     * @param azimuth Current azimuth in degrees&#10;     * @param pitch Current pitch in degrees&#10;     * @return Elevation in degrees&#10;     */&#10;    fun getDeviceLookElevation(azimuth: Double, pitch: Double): Double {&#10;        val azRad = Math.toRadians(azimuth)&#10;        val pitchRad = Math.toRadians(-pitch)  // Vorzeichen umkehren!&#10;        val x = cos(pitchRad) * sin(azRad)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val z = sin(pitchRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;object PermissionHelper {&#10;    /**&#10;     * Checks if the given permission is granted.&#10;     * @param context The context&#10;     * @param permission The permission string (e.g. Manifest.permission.ACCESS_FINE_LOCATION)&#10;     * @return true if granted, false otherwise&#10;     */&#10;    fun isPermissionGranted(context: Context, permission: String): Boolean {&#10;        return androidx.core.content.ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * Handles the result of a permission request.&#10;     * @param requestCode The request code&#10;     * @param permissions The permissions array&#10;     * @param grantResults The grant results array&#10;     * @param onGranted Callback if granted&#10;     * @param onDenied Callback if denied&#10;     */&#10;    fun handlePermissionResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray,&#10;        expectedRequestCode: Int,&#10;        onGranted: () -&gt; Unit,&#10;        onDenied: () -&gt; Unit&#10;    ) {&#10;        if (requestCode == expectedRequestCode &amp;&amp; grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;            onGranted()&#10;        } else {&#10;            onDenied()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/arrow_horizontal.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/arrow_horizontal.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;60dp&quot;&#10;    android:height=&quot;32dp&quot;&#10;    android:viewportWidth=&quot;60&quot;&#10;    android:viewportHeight=&quot;32&quot;&gt;&#10;    &#10;    &lt;!-- Horizontaler Pfeil für Azimut (blau) --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M5,14 L50,14 L50,18 L5,18 Z&quot; /&gt;&#10;    &#10;    &lt;!-- Pfeilspitze --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M46,8 L58,16 L46,24 Z&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/arrow_vertical.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/arrow_vertical.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;32dp&quot;&#10;    android:height=&quot;60dp&quot;&#10;    android:viewportWidth=&quot;32&quot;&#10;    android:viewportHeight=&quot;60&quot;&gt;&#10;&#10;    &lt;!-- Vertikaler Pfeil für Elevation (rot) --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#F44336&quot;&#10;        android:pathData=&quot;M14,5 L18,5 L18,50 L14,50 Z&quot; /&gt;&#10;&#10;    &lt;!-- Pfeilspitze --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#F44336&quot;&#10;        android:pathData=&quot;M8,46 L16,58 L24,46 Z&quot; /&gt;&#10;&lt;/vector&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    android:width=&quot;32dp&quot;&#13;&#10;    android:height=&quot;60dp&quot;&#13;&#10;    android:viewportWidth=&quot;32&quot;&#13;&#10;    android:viewportHeight=&quot;60&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Vertikaler Pfeil für Elevation (grün) --&gt;&#13;&#10;    &lt;path&#13;&#10;        android:fillColor=&quot;#4CAF50&quot;&#13;&#10;        android:pathData=&quot;M14,5 L18,5 L18,50 L14,50 Z&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;!-- Pfeilspitze --&gt;&#13;&#10;    &lt;path&#13;&#10;        android:fillColor=&quot;#4CAF50&quot;&#13;&#10;        android:pathData=&quot;M8,46 L16,58 L24,46 Z&quot; /&gt;&#13;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>