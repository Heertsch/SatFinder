<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# SatFinder Build Instructions&#10;&#10;## ⚠️ WICHTIGE HINWEISE&#10;&#10;### PowerPoint-Kompatibilität&#10;**ACHTUNG:** PowerPoint versteht keine `&amp;&amp;` Operatoren in Code-Blöcken oder Formeln!&#10;- Verwenden Sie stattdessen `AND` oder separate Bedingungen&#10;- Dies gilt für alle Präsentationen und Dokumentationen des Projekts&#10;- Bei Terminal-Befehlen in Präsentationen: Verwenden Sie `;` anstatt `&amp;&amp;`&#10;&#10;## Voraussetzungen&#10;&#10;1. Android Studio mit NDK-Unterstützung&#10;2. CMake (Version 3.10.2 oder höher)&#10;3. Android NDK (Version 26.1.10909125 oder kompatibel)&#10;&#10;## Build-Setup&#10;&#10;### 1. Repository klonen&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd SatFinder&#10;```&#10;&#10;### 2. Android Studio Setup&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Stellen Sie sicher, dass die folgenden SDK-Komponenten installiert sind:&#10;  - Android SDK Platform 35&#10;  - Android NDK (Version 26.1.10909125)&#10;  - CMake&#10;&#10;### 3. Native Dependencies&#10;Das Projekt enthält die SGP4-Bibliothek als Teil des Repositorys im `sgp4/` Verzeichnis. &#10;Keine zusätzlichen Downloads erforderlich.&#10;&#10;### 4. Build&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Gradle sollte automatisch synchronisieren&#10;- Build &gt; Make Project&#10;&#10;## Fehlerbehebung&#10;&#10;### CMake-Fehler beim Build&#10;Wenn CMake die SGP4-Quellen nicht finden kann:&#10;1. Überprüfen Sie, dass das `sgp4/libsgp4/` Verzeichnis existiert&#10;2. Führen Sie &quot;Clean Project&quot; aus und bauen Sie erneut&#10;&#10;### NDK-Version-Konflikte&#10;Falls NDK-Versionskonflikte auftreten, aktualisieren Sie die NDK-Version in `app/build.gradle.kts`:&#10;```kotlin&#10;ndkVersion = &quot;26.1.10909125&quot;&#10;```&#10;&#10;## Projektstruktur&#10;```&#10;SatFinder/&#10;├── app/&#10;│   ├── src/main/cpp/          # Native C++ Code&#10;│   │   ├── CMakeLists.txt     # CMake Build-Konfiguration&#10;│   │   └── sgp4_jni.cpp       # JNI-Interface&#10;│   └── build.gradle.kts       # Android Build-Konfiguration&#10;├── sgp4/                      # SGP4-Bibliothek (enthalten)&#10;│   └── libsgp4/              # SGP4-Quellcode&#10;└── BUILD_INSTRUCTIONS.md     # Diese Datei&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DEVELOPMENT_NOTES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DEVELOPMENT_NOTES.md" />
              <option name="updatedContent" value="# Entwicklungsnotizen - SatFinder&#10;&#10;##  Wichtige Erkenntnisse und Hinweise&#10;&#10;### PowerPoint-Kompatibilität ⚠️&#10;- **PowerPoint versteht keine `&amp;&amp;` Operatoren!**&#10;- Bei Präsentationen von Terminal-Befehlen: `;` statt `&amp;&amp;` verwenden&#10;- Bei Code-Beispielen in PowerPoint: `AND` statt `&amp;&amp;` verwenden&#10;- Datum der Erkenntnis: 2025-08-12&#10;&#10;### Terminal-Befehle für Präsentationen&#10;```bash&#10;# FALSCH für PowerPoint:&#10;cd project &amp;&amp; npm install &amp;&amp; npm start&#10;&#10;# RICHTIG für PowerPoint:&#10;cd project ; npm install ; npm start&#10;```&#10;&#10;### Code-Beispiele für Präsentationen&#10;```kotlin&#10;// FALSCH für PowerPoint:&#10;if (condition1 &amp;&amp; condition2) { }&#10;&#10;// RICHTIG für PowerPoint:&#10;if (condition1 AND condition2) { }&#10;// oder aufteilen in separate Bedingungen&#10;```&#10;&#10;##  Weitere Entwicklungsnotizen&#10;&#10;- TLE-Daten werden sowohl über Intent als auch aus Preferences geladen&#10;- GPS-Position wird für Satellitenberechnung verwendet&#10;- SGP4-Bibliothek für Orbitberechnung eingebunden&#10;&#10;##  Changelog&#10;- 2025-08-12: PowerPoint &amp;&amp; Operator Problem dokumentiert" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VERSION_0.3.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VERSION_0.3.md" />
              <option name="updatedContent" value="# SatFinder Version 0.3&#10;&#10;##  Release Datum: 12. August 2025&#10;&#10;## ✨ Neue Features&#10;- PowerPoint-Kompatibilitäts-Dokumentation hinzugefügt&#10;- Entwicklungsnotizen (DEVELOPMENT_NOTES.md) erstellt&#10;- BUILD_INSTRUCTIONS.md um wichtige PowerPoint-Hinweise erweitert&#10;&#10;##  Verbesserungen&#10;- Dokumentation für `&amp;&amp;` Operator Problem in PowerPoint&#10;- Richtlinien für PowerPoint-kompatible Code-Präsentationen&#10;- Alternative Syntax für Terminal-Befehle (`;` statt `&amp;&amp;`)&#10;&#10;##  Wichtige Erkenntnisse&#10;- **PowerPoint versteht keine `&amp;&amp;` Operatoren!**&#10;- Bei Präsentationen: `;` statt `&amp;&amp;` für Terminal-Befehle verwenden&#10;- Bei Code-Beispielen: `AND` statt `&amp;&amp;` verwenden&#10;&#10;##  Git Tag&#10;```bash&#10;git tag -a v0.3 -m &quot;Version 0.3: SatFinder mit PowerPoint-Kompatibilitäts-Dokumentation&quot;&#10;```&#10;&#10;##  Projektstruktur&#10;- Vollständige Android App mit SGP4-Bibliothek&#10;- Native C++ Integration&#10;- GPS und Magnetfeldsensor Unterstützung&#10;- Satellitenberechnung und Kompass-Anzeige" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ActivityResultHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/ActivityResultHelper.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatMathUtil.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatMathUtil.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import kotlin.math.*&#10;&#10;object SatMathUtil {&#10;    fun calculateSatelliteElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        // Berechnung der Elevation zwischen Beobachter und Satellit&#10;        val obsLatRad = Math.toRadians(observerLat)&#10;        val obsLonRad = Math.toRadians(observerLon)&#10;        val satLatRad = Math.toRadians(satLat)&#10;        val satLonRad = Math.toRadians(satLon)&#10;        val earthRadius = 6371.0 * 1000.0&#10;        val obsR = earthRadius + observerAlt&#10;        val satR = earthRadius + satAlt&#10;        val obsX = obsR * cos(obsLatRad) * cos(obsLonRad)&#10;        val obsY = obsR * cos(obsLatRad) * sin(obsLonRad)&#10;        val obsZ = obsR * sin(obsLatRad)&#10;        val satX = satR * cos(satLatRad) * cos(satLonRad)&#10;        val satY = satR * cos(satLatRad) * sin(satLonRad)&#10;        val satZ = satR * sin(satLatRad)&#10;        val dx = satX - obsX&#10;        val dy = satY - obsY&#10;        val dz = satZ - obsZ&#10;        val range = sqrt(dx * dx + dy * dy + dz * dz)&#10;        val upX = cos(obsLatRad) * cos(obsLonRad)&#10;        val upY = cos(obsLatRad) * sin(obsLonRad)&#10;        val upZ = sin(obsLatRad)&#10;        val dot = dx * upX + dy * upY + dz * upZ&#10;        val elevation = Math.toDegrees(asin(dot / range))&#10;        return elevation&#10;    }&#10;&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        // Berechnung des Azimuts zwischen Beobachter und Satellit&#10;        val obsLatRad = Math.toRadians(observerLat)&#10;        val obsLonRad = Math.toRadians(observerLon)&#10;        val satLatRad = Math.toRadians(satLat)&#10;        val satLonRad = Math.toRadians(satLon)&#10;        val dLon = satLonRad - obsLonRad&#10;        val y = sin(dLon) * cos(satLatRad)&#10;        val x = cos(obsLatRad) * sin(satLatRad) - sin(obsLatRad) * cos(satLatRad) * cos(dLon)&#10;        val azimuth = (Math.toDegrees(atan2(y, x)) + 360) % 360&#10;        return azimuth&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        // Berechnung der Distanz zwischen Beobachter und Satellit (in Metern)&#10;        val obsLatRad = Math.toRadians(observerLat)&#10;        val obsLonRad = Math.toRadians(observerLon)&#10;        val satLatRad = Math.toRadians(satLat)&#10;        val satLonRad = Math.toRadians(satLon)&#10;        val earthRadius = 6371.0 * 1000.0&#10;        val obsR = earthRadius + observerAlt&#10;        val satR = earthRadius + satAlt&#10;        val obsX = obsR * cos(obsLatRad) * cos(obsLonRad)&#10;        val obsY = obsR * cos(obsLatRad) * sin(obsLonRad)&#10;        val obsZ = obsR * sin(obsLatRad)&#10;        val satX = satR * cos(satLatRad) * cos(satLonRad)&#10;        val satY = satR * cos(satLatRad) * sin(satLonRad)&#10;        val satZ = satR * sin(satLatRad)&#10;        val dx = satX - obsX&#10;        val dy = satY - obsY&#10;        val dz = satZ - obsZ&#10;        return sqrt(dx * dx + dy * dy + dz * dz)&#10;    }&#10;&#10;    fun calculateDistanceKm(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        // Berechnung der Distanz auf der Erdoberfläche (in km)&#10;        val earthRadius = 6371.0&#10;        val dLat = Math.toRadians(satLat - observerLat)&#10;        val dLon = Math.toRadians(satLon - observerLon)&#10;        val a = sin(dLat / 2) * sin(dLat / 2) + cos(Math.toRadians(observerLat)) * cos(Math.toRadians(satLat)) * sin(dLon / 2) * sin(dLon / 2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#13;&#10;&#13;&#10;// Diese Datei wurde entfernt - alle Funktionen sind jetzt in SatMath.kt konsolidiert&#13;&#10;// Verwende stattdessen SatMath.kt direkt oder über SatelliteMathHelper.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMath.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMath.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMath.calculateDistanceKm(observerLat, observerLon, satLat, satLon) * 1000.0 // Convert to meters&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            return null&#10;        }&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import java.util.Locale&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMath.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMath.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMath.calculateDistanceKm(observerLat, observerLon, satLat, satLon) * 1000.0 // Convert to meters&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    /**&#10;     * Berechnet die Radialgeschwindigkeit und gibt sie als formatierten String in km/s zurück&#10;     */&#10;    fun calculateAndFormatRadialSpeed(&#10;        observer: Location,&#10;        tle1: String,&#10;        tle2: String,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        epoch: Date,&#10;        dtSec: Double = 10.0&#10;    ): String {&#10;        return try {&#10;            val now = Date()&#10;            val futureDate = Date(now.time + (dtSec * 1000).toLong())&#10;            val satPosFuture = getSatellitePosition(tle1, tle2, futureDate, epoch)&#10;            &#10;            if (satPosFuture != null) {&#10;                val radialSpeedMs = calculateRadialSpeed(observer, satPosNow, satPosFuture, dtSec)&#10;                val radialSpeedKms = radialSpeedMs / 1000.0 // Convert m/s to km/s&#10;                String.format(Locale.US, &quot;%+.3f km/s&quot;, radialSpeedKms)&#10;            } else {&#10;                &quot;--&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            &quot;--&quot;&#10;        }&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            return null&#10;        }&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/create_tag_v0.3.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_tag_v0.3.bat" />
              <option name="updatedContent" value="@echo off&#10;echo Erstelle Git Tag 0.3 für SatFinder Projekt&#10;echo =========================================&#10;&#10;cd /d &quot;D:\Users\heert\StudioProjects\SatFinder_02&quot;&#10;&#10;echo Prüfe Git Status...&#10;git status&#10;&#10;echo.&#10;echo Füge alle Änderungen hinzu...&#10;git add .&#10;&#10;echo.&#10;echo Committe aktuelle Änderungen...&#10;git commit -m &quot;Version 0.3 - PowerPoint Kompatibilität dokumentiert&quot;&#10;&#10;echo.&#10;echo Erstelle Git Tag 0.3...&#10;git tag -a v0.3 -m &quot;Version 0.3: SatFinder mit PowerPoint-Kompatibilitäts-Dokumentation&quot;&#10;&#10;echo.&#10;echo Zeige erstellte Tags...&#10;git tag -l&#10;&#10;echo.&#10;echo Pushe Commits zu GitHub...&#10;git push origin main&#10;&#10;echo.&#10;echo Pushe Tags zu GitHub...&#10;git push origin --tags&#10;&#10;echo.&#10;echo Fertig! Tag v0.3 wurde erfolgreich erstellt und zu GitHub gepusht.&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../SatFinder_03/BUILD_INSTRUCTIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../SatFinder_03/BUILD_INSTRUCTIONS.md" />
              <option name="originalContent" value="# SatFinder Build Instructions&#10;&#10;## Voraussetzungen&#10;&#10;1. Android Studio mit NDK-Unterstützung&#10;2. CMake (Version 3.10.2 oder höher)&#10;3. Android NDK (Version 26.1.10909125 oder kompatibel)&#10;&#10;## Build-Setup&#10;&#10;### 1. Repository klonen&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd SatFinder&#10;```&#10;&#10;### 2. Android Studio Setup&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Stellen Sie sicher, dass die folgenden SDK-Komponenten installiert sind:&#10;  - Android SDK Platform 35&#10;  - Android NDK (Version 26.1.10909125)&#10;  - CMake&#10;&#10;### 3. Native Dependencies&#10;Das Projekt enthält die SGP4-Bibliothek als Teil des Repositorys im `sgp4/` Verzeichnis. &#10;Keine zusätzlichen Downloads erforderlich.&#10;&#10;### 4. Build&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Gradle sollte automatisch synchronisieren&#10;- Build &gt; Make Project&#10;&#10;## Fehlerbehebung&#10;&#10;### CMake-Fehler beim Build&#10;Wenn CMake die SGP4-Quellen nicht finden kann:&#10;1. Überprüfen Sie, dass das `sgp4/libsgp4/` Verzeichnis existiert&#10;2. Führen Sie &quot;Clean Project&quot; aus und bauen Sie erneut&#10;&#10;### NDK-Version-Konflikte&#10;Falls NDK-Versionskonflikte auftreten, aktualisieren Sie die NDK-Version in `app/build.gradle.kts`:&#10;```kotlin&#10;ndkVersion = &quot;26.1.10909125&quot;&#10;```&#10;&#10;## Projektstruktur&#10;```&#10;SatFinder/&#10;├── app/&#10;│   ├── src/main/cpp/          # Native C++ Code&#10;│   │   ├── CMakeLists.txt     # CMake Build-Konfiguration&#10;│   │   └── sgp4_jni.cpp       # JNI-Interface&#10;│   └── build.gradle.kts       # Android Build-Konfiguration&#10;├── sgp4/                      # SGP4-Bibliothek (enthalten)&#10;│   └── libsgp4/              # SGP4-Quellcode&#10;└── BUILD_INSTRUCTIONS.md     # Diese Datei&#10;```&#10;" />
              <option name="updatedContent" value="# SatFinder Build Instructions&#13;&#10;&#13;&#10;## ⚠️ WICHTIGE HINWEISE&#13;&#10;&#13;&#10;### PowerPoint-Kompatibilität&#13;&#10;**ACHTUNG:** PowerPoint versteht keine `&amp;&amp;` Operatoren in Code-Blöcken oder Formeln!&#13;&#10;- Verwenden Sie stattdessen `AND` oder separate Bedingungen&#13;&#10;- Dies gilt für alle Präsentationen und Dokumentationen des Projekts&#13;&#10;- Bei Terminal-Befehlen in Präsentationen: Verwenden Sie `;` anstatt `&amp;&amp;`&#13;&#10;&#13;&#10;## Voraussetzungen&#13;&#10;&#13;&#10;1. Android Studio mit NDK-Unterstützung&#13;&#10;2. CMake (Version 3.10.2 oder höher)&#13;&#10;3. Android NDK (Version 26.1.10909125 oder kompatibel)&#13;&#10;&#13;&#10;## Build-Setup&#13;&#10;&#13;&#10;### 1. Repository klonen&#13;&#10;```bash&#13;&#10;git clone &lt;repository-url&gt;&#13;&#10;cd SatFinder&#13;&#10;```&#13;&#10;&#13;&#10;### 2. Android Studio Setup&#13;&#10;- Öffnen Sie das Projekt in Android Studio&#13;&#10;- Stellen Sie sicher, dass die folgenden SDK-Komponenten installiert sind:&#13;&#10;  - Android SDK Platform 35&#13;&#10;  - Android NDK (Version 26.1.10909125)&#13;&#10;  - CMake&#13;&#10;&#13;&#10;### 3. Native Dependencies&#13;&#10;Das Projekt enthält die SGP4-Bibliothek als Teil des Repositorys im `sgp4/` Verzeichnis. &#13;&#10;Keine zusätzlichen Downloads erforderlich.&#13;&#10;&#13;&#10;### 4. Build&#13;&#10;- Öffnen Sie das Projekt in Android Studio&#13;&#10;- Gradle sollte automatisch synchronisieren&#13;&#10;- Build &gt; Make Project&#13;&#10;&#13;&#10;## Fehlerbehebung&#13;&#10;&#13;&#10;### CMake-Fehler beim Build&#13;&#10;Wenn CMake die SGP4-Quellen nicht finden kann:&#13;&#10;1. Überprüfen Sie, dass das `sgp4/libsgp4/` Verzeichnis existiert&#13;&#10;2. Führen Sie &quot;Clean Project&quot; aus und bauen Sie erneut&#13;&#10;&#13;&#10;### NDK-Version-Konflikte&#13;&#10;Falls NDK-Versionskonflikte auftreten, aktualisieren Sie die NDK-Version in `app/build.gradle.kts`:&#13;&#10;```kotlin&#13;&#10;ndkVersion = &quot;26.1.10909125&quot;&#13;&#10;```&#13;&#10;&#13;&#10;## Projektstruktur&#13;&#10;```&#13;&#10;SatFinder/&#13;&#10;├── app/&#13;&#10;│   ├── src/main/cpp/          # Native C++ Code&#13;&#10;│   │   ├── CMakeLists.txt     # CMake Build-Konfiguration&#13;&#10;│   │   └── sgp4_jni.cpp       # JNI-Interface&#13;&#10;│   └── build.gradle.kts       # Android Build-Konfiguration&#13;&#10;├── sgp4/                      # SGP4-Bibliothek (enthalten)&#13;&#10;│   └── libsgp4/              # SGP4-Quellcode&#13;&#10;└── BUILD_INSTRUCTIONS.md     # Diese Datei&#13;&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../SatFinder_03/DEVELOPMENT_NOTES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../SatFinder_03/DEVELOPMENT_NOTES.md" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>