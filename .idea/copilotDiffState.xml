<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="updatedContent" value="# Ignore build directories and IDE files&#10;/build/&#10;/app/build/&#10;/.gradle/&#10;/.idea/&#10;*.iml&#10;local.properties&#10;&#10;# Ignore NDK build artifacts&#10;/app/src/main/cpp/.cxx/&#10;/app/.cxx/&#10;&#10;# Ignore OS specific files&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BUILD_INSTRUCTIONS.md" />
              <option name="updatedContent" value="# SatFinder Build Instructions&#10;&#10;## Voraussetzungen&#10;&#10;1. Android Studio mit NDK-Unterstützung&#10;2. CMake (Version 3.10.2 oder höher)&#10;3. Android NDK (Version 26.1.10909125 oder kompatibel)&#10;&#10;## Build-Setup&#10;&#10;### 1. Repository klonen&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd SatFinder&#10;```&#10;&#10;### 2. Android Studio Setup&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Stellen Sie sicher, dass die folgenden SDK-Komponenten installiert sind:&#10;  - Android SDK Platform 35&#10;  - Android NDK (Version 26.1.10909125)&#10;  - CMake&#10;&#10;### 3. Native Dependencies&#10;Das Projekt enthält die SGP4-Bibliothek als Teil des Repositorys im `sgp4/` Verzeichnis. &#10;Keine zusätzlichen Downloads erforderlich.&#10;&#10;### 4. Build&#10;- Öffnen Sie das Projekt in Android Studio&#10;- Gradle sollte automatisch synchronisieren&#10;- Build &gt; Make Project&#10;&#10;## Fehlerbehebung&#10;&#10;### CMake-Fehler beim Build&#10;Wenn CMake die SGP4-Quellen nicht finden kann:&#10;1. Überprüfen Sie, dass das `sgp4/libsgp4/` Verzeichnis existiert&#10;2. Führen Sie &quot;Clean Project&quot; aus und bauen Sie erneut&#10;&#10;### NDK-Version-Konflikte&#10;Falls NDK-Versionskonflikte auftreten, aktualisieren Sie die NDK-Version in `app/build.gradle.kts`:&#10;```kotlin&#10;ndkVersion = &quot;26.1.10909125&quot;&#10;```&#10;&#10;## Projektstruktur&#10;```&#10;SatFinder/&#10;├── app/&#10;│   ├── src/main/cpp/          # Native C++ Code&#10;│   │   ├── CMakeLists.txt     # CMake Build-Konfiguration&#10;│   │   └── sgp4_jni.cpp       # JNI-Interface&#10;│   └── build.gradle.kts       # Android Build-Konfiguration&#10;├── sgp4/                      # SGP4-Bibliothek (enthalten)&#10;│   └── libsgp4/              # SGP4-Quellcode&#10;└── BUILD_INSTRUCTIONS.md     # Diese Datei&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/cpp/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.10.2)&#10;&#10;project(sgp4native)&#10;&#10;# SGP4-Quellen direkt einbinden&#10;set(SGP4_SRC&#10;    ../../../../sgp4/libsgp4/CoordGeodetic.cc&#10;    ../../../../sgp4/libsgp4/CoordTopocentric.cc&#10;    ../../../../sgp4/libsgp4/DateTime.cc&#10;    ../../../../sgp4/libsgp4/DecayedException.cc&#10;    ../../../../sgp4/libsgp4/Eci.cc&#10;    ../../../../sgp4/libsgp4/Globals.cc&#10;    ../../../../sgp4/libsgp4/Observer.cc&#10;    ../../../../sgp4/libsgp4/OrbitalElements.cc&#10;    ../../../../sgp4/libsgp4/SatelliteException.cc&#10;    ../../../../sgp4/libsgp4/SGP4.cc&#10;    ../../../../sgp4/libsgp4/SolarPosition.cc&#10;    ../../../../sgp4/libsgp4/TimeSpan.cc&#10;    ../../../../sgp4/libsgp4/Tle.cc&#10;    ../../../../sgp4/libsgp4/TleException.cc&#10;    ../../../../sgp4/libsgp4/Util.cc&#10;    ../../../../sgp4/libsgp4/Vector.cc&#10;)&#10;&#10;# JNI-Quellen&#10;set(SGP4_JNI_SRC sgp4_jni.cpp)&#10;&#10;# Erzeuge die native Bibliothek&#10;add_library(sgp4native SHARED ${SGP4_JNI_SRC} ${SGP4_SRC})&#10;#set_target_properties(sgp4native PROPERTIES LINK_FLAGS &quot;-Wl,--max-page-size=16384&quot;)&#10;# Include-Pfade für JNI und SGP4&#10;include_directories(&#10;    ../../../../sgp4/libsgp4&#10;    ../../../../sgp4/libsgp4/include&#10;    ${CMAKE_SOURCE_DIR}&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.10.2)&#13;&#10;&#13;&#10;project(sgp4native)&#13;&#10;&#13;&#10;# SGP4-Quellen aus dem Projekt-Repository&#13;&#10;set(SGP4_SRC&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/CoordGeodetic.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/CoordTopocentric.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/DateTime.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/DecayedException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Eci.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Globals.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Observer.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/OrbitalElements.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SatelliteException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SGP4.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/SolarPosition.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/TimeSpan.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Tle.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/TleException.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Util.cc&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4/Vector.cc&#13;&#10;)&#13;&#10;&#13;&#10;# JNI-Quellen&#13;&#10;set(SGP4_JNI_SRC sgp4_jni.cpp)&#13;&#10;&#13;&#10;# Erzeuge die native Bibliothek&#13;&#10;add_library(sgp4native SHARED ${SGP4_JNI_SRC} ${SGP4_SRC})&#13;&#10;&#13;&#10;# Include-Pfade für JNI und SGP4&#13;&#10;include_directories(&#13;&#10;    ${CMAKE_SOURCE_DIR}/../../../../sgp4/libsgp4&#13;&#10;    ${CMAKE_SOURCE_DIR}&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/MapHelper.kt" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;&#10;object MapHelper {&#10;    /**&#10;     * Centers the map on the given location and adds a marker.&#10;     * @param googleMap The GoogleMap instance (nullable)&#10;     * @param location The location to center and mark&#10;     */&#10;    fun updateMapPosition(googleMap: GoogleMap?, location: Location) {&#10;        if (googleMap == null) return&#10;        val pos = LatLng(location.latitude, location.longitude)&#10;        googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(pos, 16f))&#10;        googleMap.clear()&#10;        googleMap.addMarker(MarkerOptions().position(pos).title(&quot;Present Position&quot;))&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/OverlayViewHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/OverlayViewHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.location.LocationManager&#10;import android.text.Html&#10;import android.util.Log&#10;import android.widget.TextView&#10;import java.util.*&#10;import kotlin.math.abs&#10;&#10;object OverlayViewHelper {&#10;    fun updateOverlay(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        satName: String?,&#10;        lastGoodLocation: Location?,&#10;        aosTime: Long,&#10;        losTime: Long&#10;    ) {&#10;        val satDisplay = satName ?: &quot;(no satellite selected)&quot;&#10;        val loc = lastGoodLocation ?: run {&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                val locTmp = Location(LocationManager.GPS_PROVIDER)&#10;                locTmp.latitude = lat&#10;                locTmp.longitude = lon&#10;                locTmp.altitude = alt&#10;                locTmp.time = time&#10;                locTmp&#10;            } else null&#10;        }&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        // ab hier sind tle1 und tle2 garantiert nicht null und gültig&#10;        val tle1Str = tle1!!&#10;        val tle2Str = tle2!!&#10;        var aosLos = &quot;--&quot;&#10;        var satPos: Sgp4Util.SatPos? = null&#10;        var epoch: Date? = null&#10;        var distance: Double?&#10;        var speedStr = &quot;--&quot;&#10;        val satPosInfo = &quot;Sat-Pos: --&quot;&#10;        try {&#10;            epoch = TleHelper.extractEpochFromTle(tle1Str)&#10;            val utcNow = Date() // aktuelle Zeit verwenden&#10;            if (loc != null &amp;&amp; epoch != null) {&#10;                satPos = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, utcNow, epoch)&#10;                // Debug: Prüfe, ob satPos sich bei Satellitenwechsel ändert&#10;                Log.d(&quot;SatFinder1&quot;, &quot;Name: $satName satPos: $satPos, tle1: $tle1Str, tle2: $tle2Str, utcNow: $utcNow, epoch: $epoch&quot;)&#10;                val elev = satPos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                val az = satPos?.let { SatelliteMathHelper.calculateAzimuth(loc.latitude, loc.longitude, it.lat, it.lon) }&#10;                // Debug: Prüfe, ob elev/az sich bei Satellitenwechsel ändern&#10;                Log.d(&quot;SatFinder1&quot;, &quot;elev: $elev, az: $az&quot;)&#10;                distance = satPos?.let { SatelliteMathHelper.calculateDistance(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                aosLos = if (elev != null &amp;&amp; elev &gt; 0.0) &quot;AOS&quot; else &quot;LOS&quot;&#10;                // Always calculate speed&#10;                val nowDate = utcNow&#10;                val dtSec = 10.0&#10;                val futureDate = Date(nowDate.time + (dtSec * 1000).toLong())&#10;                val satPosFuture = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, futureDate, epoch)&#10;                if (satPos != null &amp;&amp; satPosFuture != null) {&#10;                    val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(loc, satPos, satPosFuture, dtSec)&#10;                // Calculate next AOS time if LOS&#10;                var nextAosStr = &quot;--&quot;&#10;                if (aosLos == &quot;LOS&quot; &amp;&amp; tle1 != null &amp;&amp; tle2 != null &amp;&amp; loc != null &amp;&amp; epoch != null) {&#10;                    try {&#10;                        val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;                        var testTime: Date&#10;                        val maxSearch = 24 * 3600 // max 24h search&#10;                        for (i in 1..maxSearch step 10) { // 10s steps&#10;                            testTime = Date(utcNow.time + i * 1000L)&#10;                            val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, testTime, epoch)&#10;                            val elevTest = pos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) } ?: 0.0&#10;                            if (elevTest &gt; 0) {&#10;                                nextAosStr = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.US).format(testTime)&#10;                                break&#10;                            }&#10;                        }&#10;                    } catch (_: Exception) {}&#10;                }&#10;                // AOS: Show time only when LOS&#10;                val fixStatus = if (loc != null &amp;&amp; loc.hasAccuracy() &amp;&amp; loc.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - loc.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;                val aosLosStr = if (aosLos == &quot;LOS&quot; &amp;&amp; nextAosStr != &quot;--&quot;) &quot;LOS (next rise: $nextAosStr)&quot; else aosLos&#10;                val text = &quot;&quot;&quot;&#10;                    Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                    Distance: $distStr, Speed: $speedStrRounded&lt;br&gt;&#10;                    Fix: $fixStatus&lt;br&gt;&#10;                    Status: $aosLosStr&lt;br&gt;&#10;                    $satPosInfo&lt;br&gt;&#10;                    Satellite: $satDisplay&#10;                &quot;&quot;&quot;.trimIndent()&#10;                overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;            }&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    fun updateFixStatus(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        lastGoodLocation: Location?,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        getFixColor: (String) -&gt; Int,&#10;        getGpsStatus: () -&gt; String&#10;    ) {&#10;        // FixStatus-Logik ausgelagert aus MainActivity&#10;        val fixStatus = when {&#10;            lastGoodLocation == null -&gt; &quot;no GPS fix&quot;&#10;            System.currentTimeMillis() - lastGoodLocation.time &gt; 60_000 -&gt; &quot;GPS fix old&quot;&#10;            else -&gt; &quot;GPS fix&quot;&#10;        }&#10;        val gpsStatus = getGpsStatus()&#10;        val neutralColor = &quot;#FFFFFF&quot;&#10;        val fixColor = String.format(&quot;#%06X&quot;, 0xFFFFFF and getFixColor(fixStatus))&#10;        // AOS/LOS calculation&#10;        val aosLos = if (lastGoodLocation != null &amp;&amp; tle1 != null &amp;&amp; tle2 != null) {&#10;            val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;            val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;            if (epoch != null) {&#10;                val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, utcNow, epoch)&#10;                val elev = pos?.let { SatelliteMathHelper.calculateElevation(&#10;                    lastGoodLocation.latitude,&#10;                    lastGoodLocation.longitude,&#10;                    lastGoodLocation.altitude,&#10;                    it.lat, it.lon, it.alt&#10;                ) } ?: 0.0&#10;                if (elev &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            } else {&#10;                &quot;--&quot;&#10;            }&#10;        } else {&#10;            &quot;--&quot;&#10;        }&#10;        val text = &quot;&quot;&quot;&#10;            &lt;font color='$neutralColor'&gt;AOS/LOS: $aosLos&lt;br&gt;Distance: -- km&lt;br&gt;Speed: -- km/h&lt;br&gt;&lt;/font&gt;&#10;            &lt;font color='$fixColor'&gt;$fixStatus&lt;/font&gt; &lt;font color='$neutralColor'&gt;$gpsStatus&lt;/font&gt;&#10;        &quot;&quot;&quot;.trimIndent()&#10;        overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;    }&#10;&#10;    fun getFixColor(fixStatus: String): Int {&#10;        return when (fixStatus) {&#10;            &quot;GPS fix&quot; -&gt; 0x00FF00 // Grün&#10;            &quot;GPS fix old&quot; -&gt; 0xFFFF00 // Gelb&#10;            &quot;no GPS fix&quot;, &quot;no Fix&quot; -&gt; 0xFF0000 // Rot&#10;            else -&gt; 0xFFFFFF // Weiß&#10;        }&#10;    }&#10;&#10;    fun getGpsStatus(): String {&#10;        // Hier kann die Logik für den GPS-Status angepasst werden&#10;        // Beispiel: Einfacher Dummy-Status&#10;        return &quot;Status unbekannt&quot;&#10;    }&#10;&#10;    fun updateSatelliteDirectionOverlay(&#10;        overlayText: TextView,&#10;        location: Location,&#10;        satPos: Sgp4Util.SatPos?,&#10;        satName: String?,&#10;        currentAzimuth: Double,&#10;        currentPitch: Double,&#10;        tle1: String,&#10;        tle2: String&#10;    ) {&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        if (satPos == null) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;No valid satellite data. Please select a satellite.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        try {&#10;            val azimuth = SatelliteMathHelper.calculateAzimuth(location.latitude, location.longitude, satPos.lat, satPos.lon)&#10;            val elevation = SatelliteMathHelper.calculateElevation(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            val distance = SatelliteMathHelper.calculateDistance(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            var speed = 0.0&#10;            val dtSec = 10.0&#10;            val now = Date()&#10;            val futureDate = Date(now.time + (dtSec * 1000).toLong())&#10;            val posFut = SatelliteMathHelper.getSatellitePosition(satName ?: &quot;&quot;, &quot;&quot;, futureDate, now)&#10;            if (posFut != null) {&#10;                val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(location, satPos, posFut, dtSec)&#10;                speed = radialSpeed / 1000.0 // km/s&#10;            }&#10;            val fixStatus = if (location.hasAccuracy() &amp;&amp; location.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - location.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;            val aosLos = if (elevation &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            val azStr = String.format(Locale.US, &quot;%.1f°&quot;, azimuth)&#10;            val elStr = String.format(Locale.US, &quot;%.1f°&quot;, elevation)&#10;            val distStr = String.format(Locale.US, &quot;%.1f km&quot;, distance)&#10;            val speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, speed*1000.0)&#10;            val latDir = if (satPos.lat &gt;= 0) &quot;N&quot; else &quot;S&quot;&#10;            val lonDir = if (satPos.lon &gt;= 0) &quot;E&quot; else &quot;W&quot;&#10;            val latAbs = abs(satPos.lat)&#10;            val lonAbs = abs(satPos.lon)&#10;            val satPosInfo = &quot;Lat: %.1f° %s, Lon: %.1f° %s, Height: %.0f Km&quot;.format(latAbs, latDir, lonAbs, lonDir, satPos.alt/1000.0)&#10;            val text = &quot;&quot;&quot;&#10;                Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                Distance: $distStr km, Speed: $speedStr&lt;br&gt;&#10;                Fix: $fixStatus&lt;br&gt;&#10;                Status: $aosLos&lt;br&gt;&#10;                Sat-Pos: $satPosInfo&lt;br&gt;&#10;                Satellite: ${satName ?: &quot;(no name)&quot;}&#10;            &quot;&quot;&quot;.trimIndent()&#10;            overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(overlayText.context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = overlayText.context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(overlayText.context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            overlayText.context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob ein TLE-String gültig ist (mind. 69 Zeichen, nicht nur Leerzeichen, nicht null).&#10;     */&#10;    fun isValidTleLine(line: String?): Boolean {&#10;        return !line.isNullOrBlank() &amp;&amp; line.trim().length &gt;= 69&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.location.LocationManager&#10;import android.text.Html&#10;import android.util.Log&#10;import android.widget.TextView&#10;import java.util.*&#10;import kotlin.math.abs&#10;&#10;object OverlayViewHelper {&#10;    fun updateOverlay(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        satName: String?,&#10;        lastGoodLocation: Location?,&#10;        aosTime: Long,&#10;        losTime: Long&#10;    ) {&#10;        val satDisplay = satName ?: &quot;(no satellite selected)&quot;&#10;        val loc = lastGoodLocation ?: run {&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                val locTmp = Location(LocationManager.GPS_PROVIDER)&#10;                locTmp.latitude = lat&#10;                locTmp.longitude = lon&#10;                locTmp.altitude = alt&#10;                locTmp.time = time&#10;                locTmp&#10;            } else null&#10;        }&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        // ab hier sind tle1 und tle2 garantiert nicht null und gültig&#10;        val tle1Str = tle1!!&#10;        val tle2Str = tle2!!&#10;        var aosLos = &quot;--&quot;&#10;        var satPos: Sgp4Util.SatPos? = null&#10;        var epoch: Date? = null&#10;        var distance: Double?&#10;        var speedStr = &quot;--&quot;&#10;        val satPosInfo = &quot;Sat-Pos: --&quot;&#10;        try {&#10;            epoch = TleHelper.extractEpochFromTle(tle1Str)&#10;            val utcNow = Date() // aktuelle Zeit verwenden&#10;            if (loc != null &amp;&amp; epoch != null) {&#10;                satPos = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, utcNow, epoch)&#10;                // Debug: Prüfe, ob satPos sich bei Satellitenwechsel ändert&#10;                Log.d(&quot;SatFinder1&quot;, &quot;Name: $satName satPos: $satPos, tle1: $tle1Str, tle2: $tle2Str, utcNow: $utcNow, epoch: $epoch&quot;)&#10;                val elev = satPos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                val az = satPos?.let { SatelliteMathHelper.calculateAzimuth(loc.latitude, loc.longitude, it.lat, it.lon) }&#10;                // Debug: Prüfe, ob elev/az sich bei Satellitenwechsel ändern&#10;                Log.d(&quot;SatFinder1&quot;, &quot;elev: $elev, az: $az&quot;)&#10;                distance = satPos?.let { SatelliteMathHelper.calculateDistance(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) }&#10;                aosLos = if (elev != null &amp;&amp; elev &gt; 0.0) &quot;AOS&quot; else &quot;LOS&quot;&#10;                // Always calculate speed&#10;                val nowDate = utcNow&#10;                val dtSec = 10.0&#10;                val futureDate = Date(nowDate.time + (dtSec * 1000).toLong())&#10;                val satPosFuture = SatelliteMathHelper.getSatellitePosition(tle1Str, tle2Str, futureDate, epoch)&#10;                if (satPos != null &amp;&amp; satPosFuture != null) {&#10;                    val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(loc, satPos, satPosFuture, dtSec)&#10;                    Log.d(&quot;SatFinder3&quot;, &quot;Speed-Berechnung: now=(${satPos.lat},${satPos.lon},${satPos.alt}), future=(${satPosFuture.lat},${satPosFuture.lon},${satPosFuture.alt}), dtSec=$dtSec, speed=$radialSpeed&quot;)&#10;                    speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, radialSpeed)&#10;                }&#10;                // Round values and adjust units&#10;                val azStr = az?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val elStr = elev?.let { String.format(Locale.US, &quot;%.1f°&quot;, it) } ?: &quot;--&quot;&#10;                val distStr = distance?.let { String.format(Locale.US, &quot;%.1f km&quot;, it/1000.0) } ?: &quot;--&quot;&#10;                val speedStrRounded = speedStr&#10;                // Calculate next AOS time if LOS&#10;                var nextAosStr = &quot;--&quot;&#10;                if (aosLos == &quot;LOS&quot; &amp;&amp; tle1 != null &amp;&amp; tle2 != null &amp;&amp; loc != null &amp;&amp; epoch != null) {&#10;                    try {&#10;                        val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;                        var testTime: Date&#10;                        val maxSearch = 24 * 3600 // max 24h search&#10;                        for (i in 1..maxSearch step 10) { // 10s steps&#10;                            testTime = Date(utcNow.time + i * 1000L)&#10;                            val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, testTime, epoch)&#10;                            val elevTest = pos?.let { SatelliteMathHelper.calculateElevation(loc.latitude, loc.longitude, loc.altitude, it.lat, it.lon, it.alt) } ?: 0.0&#10;                            if (elevTest &gt; 0) {&#10;                                nextAosStr = java.text.SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.US).format(testTime)&#10;                                break&#10;                            }&#10;                        }&#10;                    } catch (_: Exception) {}&#10;                }&#10;                // AOS: Show time only when LOS&#10;                val fixStatus = if (loc != null &amp;&amp; loc.hasAccuracy() &amp;&amp; loc.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - loc.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;                val aosLosStr = if (aosLos == &quot;LOS&quot; &amp;&amp; nextAosStr != &quot;--&quot;) &quot;LOS (next rise: $nextAosStr)&quot; else aosLos&#10;                val text = &quot;&quot;&quot;&#10;                    Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                    Distance: $distStr, Speed: $speedStrRounded&lt;br&gt;&#10;                    Fix: $fixStatus&lt;br&gt;&#10;                    Status: $aosLosStr&lt;br&gt;&#10;                    $satPosInfo&lt;br&gt;&#10;                    Satellite: $satDisplay&#10;                &quot;&quot;&quot;.trimIndent()&#10;                overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;            }&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    fun updateFixStatus(&#10;        context: Context,&#10;        overlayText: TextView,&#10;        lastGoodLocation: Location?,&#10;        tle1: String?,&#10;        tle2: String?,&#10;        getFixColor: (String) -&gt; Int,&#10;        getGpsStatus: () -&gt; String&#10;    ) {&#10;        // FixStatus-Logik ausgelagert aus MainActivity&#10;        val fixStatus = when {&#10;            lastGoodLocation == null -&gt; &quot;no GPS fix&quot;&#10;            System.currentTimeMillis() - lastGoodLocation.time &gt; 60_000 -&gt; &quot;GPS fix old&quot;&#10;            else -&gt; &quot;GPS fix&quot;&#10;        }&#10;        val gpsStatus = getGpsStatus()&#10;        val neutralColor = &quot;#FFFFFF&quot;&#10;        val fixColor = String.format(&quot;#%06X&quot;, 0xFFFFFF and getFixColor(fixStatus))&#10;        // AOS/LOS calculation&#10;        val aosLos = if (lastGoodLocation != null &amp;&amp; tle1 != null &amp;&amp; tle2 != null) {&#10;            val utcNow = java.util.Calendar.getInstance(java.util.TimeZone.getTimeZone(&quot;UTC&quot;)).time&#10;            val epoch = TleHelper.extractEpochFromTle(tle1!!)&#10;            if (epoch != null) {&#10;                val pos = SatelliteMathHelper.getSatellitePosition(tle1!!, tle2!!, utcNow, epoch)&#10;                val elev = pos?.let { SatelliteMathHelper.calculateElevation(&#10;                    lastGoodLocation.latitude,&#10;                    lastGoodLocation.longitude,&#10;                    lastGoodLocation.altitude,&#10;                    it.lat, it.lon, it.alt&#10;                ) } ?: 0.0&#10;                if (elev &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            } else {&#10;                &quot;--&quot;&#10;            }&#10;        } else {&#10;            &quot;--&quot;&#10;        }&#10;        val text = &quot;&quot;&quot;&#10;            &lt;font color='$neutralColor'&gt;AOS/LOS: $aosLos&lt;br&gt;Distance: -- km&lt;br&gt;Speed: -- km/h&lt;br&gt;&lt;/font&gt;&#10;            &lt;font color='$fixColor'&gt;$fixStatus&lt;/font&gt; &lt;font color='$neutralColor'&gt;$gpsStatus&lt;/font&gt;&#10;        &quot;&quot;&quot;.trimIndent()&#10;        overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;    }&#10;&#10;    fun getFixColor(fixStatus: String): Int {&#10;        return when (fixStatus) {&#10;            &quot;GPS fix&quot; -&gt; 0x00FF00 // Grün&#10;            &quot;GPS fix old&quot; -&gt; 0xFFFF00 // Gelb&#10;            &quot;no GPS fix&quot;, &quot;no Fix&quot; -&gt; 0xFF0000 // Rot&#10;            else -&gt; 0xFFFFFF // Weiß&#10;        }&#10;    }&#10;&#10;    fun getGpsStatus(): String {&#10;        // Hier kann die Logik für den GPS-Status angepasst werden&#10;        // Beispiel: Einfacher Dummy-Status&#10;        return &quot;Status unbekannt&quot;&#10;    }&#10;&#10;    fun updateSatelliteDirectionOverlay(&#10;        overlayText: TextView,&#10;        location: Location,&#10;        satPos: Sgp4Util.SatPos?,&#10;        satName: String?,&#10;        currentAzimuth: Double,&#10;        currentPitch: Double,&#10;        tle1: String,&#10;        tle2: String&#10;    ) {&#10;        if (!isValidTleLine(tle1) || !isValidTleLine(tle2)) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Keine oder ungültige TLE-Daten. Bitte wählen Sie einen Satelliten.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        if (satPos == null) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;No valid satellite data. Please select a satellite.&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            return&#10;        }&#10;        try {&#10;            val azimuth = SatelliteMathHelper.calculateAzimuth(location.latitude, location.longitude, satPos.lat, satPos.lon)&#10;            val elevation = SatelliteMathHelper.calculateElevation(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            val distance = SatelliteMathHelper.calculateDistance(location.latitude, location.longitude, location.altitude, satPos.lat, satPos.lon, satPos.alt)&#10;            var speed = 0.0&#10;            val dtSec = 10.0&#10;            val now = Date()&#10;            val futureDate = Date(now.time + (dtSec * 1000).toLong())&#10;            val posFut = SatelliteMathHelper.getSatellitePosition(satName ?: &quot;&quot;, &quot;&quot;, futureDate, now)&#10;            if (posFut != null) {&#10;                val radialSpeed = SatelliteMathHelper.calculateRadialSpeed(location, satPos, posFut, dtSec)&#10;                speed = radialSpeed / 1000.0 // km/s&#10;            }&#10;            val fixStatus = if (location.hasAccuracy() &amp;&amp; location.accuracy &lt; 100 &amp;&amp; System.currentTimeMillis() - location.time &lt; 60_000) &quot;Fix&quot; else &quot;no Fix&quot;&#10;            val aosLos = if (elevation &gt; 0) &quot;AOS&quot; else &quot;LOS&quot;&#10;            val azStr = String.format(Locale.US, &quot;%.1f°&quot;, azimuth)&#10;            val elStr = String.format(Locale.US, &quot;%.1f°&quot;, elevation)&#10;            val distStr = String.format(Locale.US, &quot;%.1f km&quot;, distance)&#10;            val speedStr = String.format(Locale.US, &quot;%+.1f m/s&quot;, speed*1000.0)&#10;            val latDir = if (satPos.lat &gt;= 0) &quot;N&quot; else &quot;S&quot;&#10;            val lonDir = if (satPos.lon &gt;= 0) &quot;E&quot; else &quot;W&quot;&#10;            val latAbs = abs(satPos.lat)&#10;            val lonAbs = abs(satPos.lon)&#10;            val satPosInfo = &quot;Lat: %.1f° %s, Lon: %.1f° %s, Height: %.0f Km&quot;.format(latAbs, latDir, lonAbs, lonDir, satPos.alt/1000.0)&#10;            val text = &quot;&quot;&quot;&#10;                Azimuth: $azStr, Elevation: $elStr&lt;br&gt;&#10;                Distance: $distStr km, Speed: $speedStr&lt;br&gt;&#10;                Fix: $fixStatus&lt;br&gt;&#10;                Status: $aosLos&lt;br&gt;&#10;                Sat-Pos: $satPosInfo&lt;br&gt;&#10;                Satellite: ${satName ?: &quot;(no name)&quot;}&#10;            &quot;&quot;&quot;.trimIndent()&#10;            overlayText.text = Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY)&#10;        } catch (e: Exception) {&#10;            overlayText.text = Html.fromHtml(&quot;&lt;b&gt;Ungültige TLE-Daten: ${e.message}&lt;/b&gt;&quot;, Html.FROM_HTML_MODE_LEGACY)&#10;            android.widget.Toast.makeText(overlayText.context, &quot;Ungültige TLE-Daten: ${e.message}&quot;, android.widget.Toast.LENGTH_LONG).show()&#10;            val prefs = overlayText.context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit().clear().apply()&#10;            val intent = android.content.Intent(overlayText.context, support.hb9hci.satfinder.SatelliteSelectionActivity::class.java)&#10;            intent.flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK&#10;            overlayText.context.startActivity(intent)&#10;            return&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Prüft, ob ein TLE-String gültig ist (mind. 69 Zeichen, nicht nur Leerzeichen, nicht null).&#10;     */&#10;    fun isValidTleLine(line: String?): Boolean {&#10;        return !line.isNullOrBlank() &amp;&amp; line.trim().length &gt;= 69&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/PreferencesHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;        return if (prefs.contains(&quot;fix_lat&quot;)) {&#10;            val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;            val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;            val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;            val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;            val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;            loc.latitude = lat&#10;            loc.longitude = lon&#10;            loc.altitude = alt&#10;            loc.time = time&#10;            loc&#10;        } else null&#10;        return Triple(tle1, tle2, satName)&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;import android.util.Log&#10;&#10;object PreferencesHelper {&#10;    fun saveLocation(context: Context, location: Location) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putFloat(&quot;fix_lat&quot;, location.latitude.toFloat())&#10;            putFloat(&quot;fix_lon&quot;, location.longitude.toFloat())&#10;            putFloat(&quot;fix_alt&quot;, location.altitude.toFloat())&#10;            putLong(&quot;fix_time&quot;, location.time)&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadLocation(context: Context): Location? {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            if (prefs.contains(&quot;fix_lat&quot;)) {&#10;                val lat = prefs.getFloat(&quot;fix_lat&quot;, 0f).toDouble()&#10;                val lon = prefs.getFloat(&quot;fix_lon&quot;, 0f).toDouble()&#10;                val alt = prefs.getFloat(&quot;fix_alt&quot;, 0f).toDouble()&#10;                val time = prefs.getLong(&quot;fix_time&quot;, 0L)&#10;                if (lat == 0.0 &amp;&amp; lon == 0.0) {&#10;                    Log.w(&quot;PreferencesHelper&quot;, &quot;Location in Preferences ist 0/0 – wird ignoriert.&quot;)&#10;                    return null&#10;                }&#10;                val loc = android.location.Location(android.location.LocationManager.GPS_PROVIDER)&#10;                loc.latitude = lat&#10;                loc.longitude = lon&#10;                loc.altitude = alt&#10;                loc.time = time&#10;                loc&#10;            } else null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Location aus Preferences&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    fun saveSatelliteData(context: Context, tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double) {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            putString(&quot;last_tle1&quot;, tle1)&#10;            putString(&quot;last_tle2&quot;, tle2)&#10;            putString(&quot;last_satName&quot;, satName)&#10;            putFloat(&quot;last_satLat&quot;, satLat.toFloat())&#10;            putFloat(&quot;last_satLon&quot;, satLon.toFloat())&#10;            putFloat(&quot;last_satAltMeters&quot;, satAltMeters.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun loadSatelliteData(context: Context): Triple&lt;String?, String?, String?&gt; {&#10;        val prefs = context.getSharedPreferences(&quot;satfinder_prefs&quot;, Context.MODE_PRIVATE)&#10;        return try {&#10;            val tle1 = prefs.getString(&quot;last_tle1&quot;, null)&#10;            val tle2 = prefs.getString(&quot;last_tle2&quot;, null)&#10;            val satName = prefs.getString(&quot;last_satName&quot;, null)&#10;            Triple(tle1, tle2, satName)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;PreferencesHelper&quot;, &quot;Fehler beim Laden der Satellitendaten aus Preferences&quot;, e)&#10;            Triple(null, null, null)&#10;        }&#10;    }&#10;}&#10;&#10;object ActivityResultHelper {&#10;    fun handleSatelliteSelectionResult(&#10;        context: Context,&#10;        data: Intent?,&#10;        onUpdate: (tle1: String?, tle2: String?, satName: String?, satLat: Double, satLon: Double, satAltMeters: Double, periodMin: Double, inclination: Double, heightKm: Double, aosTime: Long, losTime: Long) -&gt; Unit&#10;    ) {&#10;        if (data == null) return&#10;        val satLat = data.getDoubleExtra(&quot;satLat&quot;, 0.0)&#10;        val satLon = data.getDoubleExtra(&quot;satLon&quot;, 0.0)&#10;        val satAltMeters = data.getDoubleExtra(&quot;satAlt&quot;, 0.0)&#10;        val tle1 = data.getStringExtra(&quot;tle1&quot;)&#10;        val tle2 = data.getStringExtra(&quot;tle2&quot;)&#10;        val satName = data.getStringExtra(&quot;satName&quot;)&#10;        val periodMin = data.getDoubleExtra(&quot;periodMin&quot;, 92.0)&#10;        val inclination = data.getDoubleExtra(&quot;inclination&quot;, 51.6)&#10;        val heightKm = data.getDoubleExtra(&quot;heightKm&quot;, 420.0)&#10;        val aosTime = data.getLongExtra(&quot;aos&quot;, -1L)&#10;        val losTime = data.getLongExtra(&quot;los&quot;, -1L)&#10;        onUpdate(tle1, tle2, satName, satLat, satLon, satAltMeters, periodMin, inclination, heightKm, aosTime, losTime)&#10;        PreferencesHelper.saveSatelliteData(context, tle1, tle2, satName, satLat, satLon, satAltMeters)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SatelliteMathHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.location.Location&#10;import java.util.Date&#10;import kotlin.math.*&#10;&#10;object SatelliteMathHelper {&#10;    fun calculateAzimuth(observerLat: Double, observerLon: Double, satLat: Double, satLon: Double): Double {&#10;        return SatMathUtil.calculateAzimuth(observerLat, observerLon, satLat, satLon)&#10;    }&#10;&#10;    fun calculateElevation(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateSatelliteElevation(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateDistance(observerLat: Double, observerLon: Double, observerAlt: Double, satLat: Double, satLon: Double, satAlt: Double): Double {&#10;        return SatMathUtil.calculateDistance(observerLat, observerLon, observerAlt, satLat, satLon, satAlt)&#10;    }&#10;&#10;    fun calculateRadialSpeed(&#10;        observer: Location,&#10;        satPosNow: Sgp4Util.SatPos,&#10;        satPosFuture: Sgp4Util.SatPos,&#10;        dtSec: Double&#10;    ): Double {&#10;        val rad = 6371.0 * 1000.0 + observer.altitude&#10;        val latRad = Math.toRadians(observer.latitude)&#10;        val lonRad = Math.toRadians(observer.longitude)&#10;        val obsX = rad * cos(latRad) * cos(lonRad)&#10;        val obsY = rad * cos(latRad) * sin(lonRad)&#10;        val obsZ = rad * sin(latRad)&#10;        val satRadNow = 6371.0 * 1000.0 + satPosNow.alt&#10;        val satLatRadNow = Math.toRadians(satPosNow.lat)&#10;        val satLonRadNow = Math.toRadians(satPosNow.lon)&#10;        val satXNow = satRadNow * cos(satLatRadNow) * cos(satLonRadNow)&#10;        val satYNow = satRadNow * cos(satLatRadNow) * sin(satLonRadNow)&#10;        val satZNow = satRadNow * sin(satLatRadNow)&#10;        val satRadFut = 6371.0 * 1000.0 + satPosFuture.alt&#10;        val satLatRadFut = Math.toRadians(satPosFuture.lat)&#10;        val satLonRadFut = Math.toRadians(satPosFuture.lon)&#10;        val satXFut = satRadFut * cos(satLatRadFut) * cos(satLonRadFut)&#10;        val satYFut = satRadFut * cos(satLatRadFut) * sin(satLonRadFut)&#10;        val satZFut = satRadFut * sin(satLatRadFut)&#10;        val vxNow = satXNow - obsX&#10;        val vyNow = satYNow - obsY&#10;        val vzNow = satZNow - obsZ&#10;        val distNow = sqrt(vxNow*vxNow + vyNow*vyNow + vzNow*vzNow)&#10;        val vxFut = satXFut - obsX&#10;        val vyFut = satYFut - obsY&#10;        val vzFut = satZFut - obsZ&#10;        val distFut = sqrt(vxFut*vxFut + vyFut*vyFut + vzFut*vzFut)&#10;        return (distFut - distNow) / dtSec&#10;    }&#10;&#10;    fun getSatellitePosition(tle1: String, tle2: String, date: Date, epoch: Date): Sgp4Util.SatPos? {&#10;        if (!OverlayViewHelper.isValidTleLine(tle1) || !OverlayViewHelper.isValidTleLine(tle2)) {&#10;            return null&#10;        }&#10;        return Sgp4Util.getSatPos(tle1, tle2, date, epoch)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/support/hb9hci/satfinder/SensorHelper.kt" />
              <option name="originalContent" value="package support.hb9hci.satfinder&#10;&#10;        val pitchRad = Math.toRadians(pitch)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package support.hb9hci.satfinder&#10;&#10;import android.content.Context&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorManager&#10;import android.content.pm.PackageManager&#10;import kotlin.math.*&#10;&#10;object SensorHelper {&#10;    /**&#10;     * Extracts azimuth and pitch from a rotation vector event.&#10;     * @param event The SensorEvent (rotation vector)&#10;     * @return Pair(azimuth, pitch) in degrees&#10;     */&#10;    fun getAzimuthAndPitch(event: SensorEvent): Pair&lt;Double, Double&gt; {&#10;        val rotationMatrix = FloatArray(9)&#10;        SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;        val orientation = FloatArray(3)&#10;        SensorManager.getOrientation(rotationMatrix, orientation)&#10;        val azimuth = (Math.toDegrees(orientation[0].toDouble()) + 360) % 360&#10;        val pitch = Math.toDegrees(orientation[1].toDouble())&#10;        return Pair(azimuth, pitch)&#10;    }&#10;&#10;    /**&#10;     * Calculates the device's look elevation (line of sight relative to horizon).&#10;     * @param azimuth Current azimuth in degrees&#10;     * @param pitch Current pitch in degrees&#10;     * @return Elevation in degrees&#10;     */&#10;    fun getDeviceLookElevation(azimuth: Double, pitch: Double): Double {&#10;        val azRad = Math.toRadians(azimuth)&#10;        val pitchRad = Math.toRadians(pitch)&#10;        val x = cos(pitchRad) * sin(azRad)&#10;        val y = cos(pitchRad) * cos(azRad)&#10;        val z = sin(pitchRad)&#10;        val norm = sqrt(x * x + y * y + z * z)&#10;        return Math.toDegrees(asin(z / norm))&#10;    }&#10;}&#10;&#10;object PermissionHelper {&#10;    /**&#10;     * Checks if the given permission is granted.&#10;     * @param context The context&#10;     * @param permission The permission string (e.g. Manifest.permission.ACCESS_FINE_LOCATION)&#10;     * @return true if granted, false otherwise&#10;     */&#10;    fun isPermissionGranted(context: Context, permission: String): Boolean {&#10;        return androidx.core.content.ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * Handles the result of a permission request.&#10;     * @param requestCode The request code&#10;     * @param permissions The permissions array&#10;     * @param grantResults The grant results array&#10;     * @param onGranted Callback if granted&#10;     * @param onDenied Callback if denied&#10;     */&#10;    fun handlePermissionResult(&#10;        requestCode: Int,&#10;        permissions: Array&lt;out String&gt;,&#10;        grantResults: IntArray,&#10;        expectedRequestCode: Int,&#10;        onGranted: () -&gt; Unit,&#10;        onDenied: () -&gt; Unit&#10;    ) {&#10;        if (requestCode == expectedRequestCode &amp;&amp; grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;            onGranted()&#10;        } else {&#10;            onDenied()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/arrow_horizontal.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/arrow_horizontal.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;60dp&quot;&#10;    android:height=&quot;32dp&quot;&#10;    android:viewportWidth=&quot;60&quot;&#10;    android:viewportHeight=&quot;32&quot;&gt;&#10;    &#10;    &lt;!-- Horizontaler Pfeil für Azimut (blau) --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M5,14 L50,14 L50,18 L5,18 Z&quot; /&gt;&#10;    &#10;    &lt;!-- Pfeilspitze --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M46,8 L58,16 L46,24 Z&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>